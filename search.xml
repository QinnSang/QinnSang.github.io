<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TCP的报文格式与连接]]></title>
    <url>%2F2019%2F09%2F09%2FTCP%E7%9A%84%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%E4%B8%8E%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[TCP是一个面向连接的、提供可靠传输的、全双工通信、面向字节流的传输层协议。 本文先讲述TCP报文格式以及TCP连接的过程。 TCP报文段首部格式 源端口（2）： 数据发送方的端口号。 目的端口（2）： 数据接受方的端口号。 序号（4）：seq序号，记录本报文段所发送的第一个字节的序号。 例如：一报文段字段值是301，携带数据共有100字节，因为在TCP连接中传送的字节流中的每一个字节都按顺序编号，所以本报文段的第一个字节的序号是301，最后一个字节的序号是400，那么下一个报文段应当从401开始 确认号（4）：ack序号，即接收端希望收到的下一个数据报文中的第一个字节的序号。 ​ 只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。（上面例子里确认号=401） 数据偏移（4位）：表示TCP报文段的数据起始处距离TCP报文段的起始处有多远（即TCP报文段的首部长度） 数据偏移的单位是32bit，即4字节；因为4位二进制能够表是的最大十进制数是15，所以数据偏移的最大长度是15*4=60字节，除去固定部分的20字节，选项字段最大不能超过40字节 保留（6位） 紧急比特URG（1位）：当值为1时表示次报文段中有需要紧急处理。 确认比特ACK（1位）：确认序号是否有效，为1时有效，为0时无效。TCP规定连接建立后传送报文段ACK=1 推送比特PSH（1位）：接收方应该尽快将这个报文交给应用层。 复位比特RST（1位）：重置连接，值为1时表示TCP连接存在严重的错误，需要重新进行连接。 同步比特SYN（1位）：建立连接，在连接建立时同步序号，SYN=1时表示这是一个连接请求或连接接受报文 当SYN=1且ACK=0时，表明这时一个连接请求报文段 当SYN=1且ACK=1时，表明对方同意建立连接 所以SYN=1时表示这是一个连接请求或连接接受报文 终止比特FIN（1位）： 用于释放连接，值为1表示要发送的数据报已经发送完毕，需要释放传送连接。 窗口字段（2）：接收端根据缓存空间的大小确定自己接受窗口的大小，限制发送放的窗口上限。 检验和：用来检验首部和数据两部分的正确性。 紧急指针字段：本报文紧急报文的最后一个字节的序号。 需要注意的是：不要将确认序号ack与标志位中的ACK搞混了，确认方ack=发起方seq+1，两端配对。 TCP的连接每一条TCP连接有两个端点，端点叫socket（套接字） socket是一个 五元组，包括：源IP、源端口、目的IP、目的端口、类型：TCP or UDP 这个五元组，即标识了一条可用的连接。例如，本地IP是180.172.35.150，在浏览器中连接某一个Web服务器，例如百度，这条socket连接的五元组可能就是： [180.172.35.150:45678, tcp, 180.97.33.108:80] 源IP为你的出口IP地址 180.172.35.150，源端口为随机端口 45678，目的IP为百度的某一个负载均衡服务器IP 180.97.33.108，端口为HTTP标准的80端口 三次握手三次握手的过程： 刚开始客户端处于 closed 的状态，服务端处于 listen 状态。然后 1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号seq=X（seq利用ISN生成）。此时客户端处于 SYN_Send （同步已发送） 状态。 2、第二次握手：服务器收到客户端的 SYN 报文后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号seq=Y，同时会把客户端的seq + 1 作为 Ack （确认序号）的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD（同步收到）的状态。 3、第三次握手：客户端收到服务器 SYN 报文之后，会发送一个 ACK应答 报文，也是一样把服务器的seq + 1 作为 Ack 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。（此时客户端可以通过ACK报文段发送数据，但如果不发送数据则不消耗序号） 4、服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方已建立连接 三次握手的作用 1、确认双方的接受、发送能力是否正常，是否可以传送数据。 2、同步双方的初始化序列号，为后面的可靠传送做准备。 3、协商窗口大小，同时接收方预留数据缓存区，为后面的可靠传送做准备。 （ISN）是固定的吗 三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。 123ISN = M + F(localhost, localport, remotehost, remoteport)M是一个计时器，每隔4毫秒加1。F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。所以要保证hash算法不能被外部轻易推算得出。 ISN是随机的，所以序列号容易就会超过2^31-1，就出现了“tcp序列号回绕”问题 参考博文 四次挥手由于socket是全双工的工作模式，一个socket的关闭，是需要四次握手来完成的。 四次挥手的过程： 刚开始双方都处于 establised 状态，假如是客户端主动发起关闭请求（调用close()方法），则： 1、第一次挥手：客户端发送一个 FIN 终止报文给服务器，报文中指定一个初始化序列号seq=U。此时客户端处于FIN_WAIT1状态。 2、第二次挥手：服务端收到 FIN 之后，因为还有数据未发送完，所以服务器会先发送一个 ACK 应答报文，指定一个初始化序列号seq=V，且把客户端的序列号值seq + 1 作为确认序号的值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。客户端等待服务器关闭，则进入FIN_WAIT_2状态；此时，客户端 等待 服务器 发起关闭请求 3、第三次挥手：服务器在完成所有数据发送后，主动发起关闭请求，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个初始化序列号seq=W。此时服务端处于 LAST_ACK 的状态。 4、第四次挥手：客户端收到 FIN 之后，发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。 5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。等待最长报文段寿命时间，主动关闭的一方，结束TIME-WAIT，进入CLOSED状态 四次挥手的作用：确保数据能够完成传输，而不是发送FIN报文后对方立即关闭连接 参考博文：关于3次握手与4次挥手 TIME_WAIT的作用或2MSL的作用 防止前一个连接上延迟的数据包或丢失重传的数据包，被后面复用的连接错误接收(异常:数据丢失或传输慢） SEQ=3的数据包丢失，重传第一次，没有得到ACK确认 如果没有TIME_WAIT，或TIME_WAIT时间非常短，那么关闭的连接马上被重用，并连续发送SEQ=1,2 的数据包 【180.172.35.150:45678, tcp, 180.97.33.108:80 的状态变为了CLOSED，源端口可被再次利用】【对180.97.33.108:80新建的连接，复用了之前的随机端口45678】 此时，前面的连接上的SEQ=3的数据包再次重传，同时，seq的序号刚好也是3（这个很重要，不然，SEQ的序号对不上，就会RST掉），此时，前面一个连接上的数据被后面的一个连接错误的接收 确保连接方能在时间范围内，关闭自己的连接（也是因为丢包导致的） 总的来说就是为了解决网络的丢包和网络不稳定所带来的其他问题 参考博文：你所不知道的TIME_WAIT]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM虚拟机]]></title>
    <url>%2F2019%2F08%2F31%2FJVM%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[讲述Java内存模型 Java体系 Java内存模型1. Run-Time Data Areas 运行时数据区 JAVA虚拟机定义了各种用于程序执行时的运行时数据区： a) 一些数据区是与虚拟机的生命周期一致的：创建于虚拟机开始运行时，销毁于虚拟机退出时 b) 一些数据区是与线程生命周期一致的：创建于线程创建，毁于线程推出 在数据区中： 线程私有：Program Counter Register、JVM Stacks、Native Method Stacks（无GC） 线程共享：Heap、Method Area（有GC） 1.1 Program Counter Register 程序计数器程序计数器是指CPU中的寄存器 执行java方法时，程序计数器是有值的，存储的是当前执行的字节码指令的地址（保存下一条指令的所在存储单元的地址）CPU根据保存的指令地址找到指令，然后在执行。目的是防止多线程执行时出现干扰，单线程的话可以没有PC 执行native本地方法时，程序计数器的值为空（Undefined）：因为native方法是java直接调用本地C/C++库进行实现，那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。 程序计数器PC有足够的空间存储返回地址信息，占用的内存很小，所以PC是唯一一个JVM中没有OutOfMemoryError的区域。 1.2 Native Method Stacks 本地方法栈 作用场景：在程序调用或JVM调用本地方法（非java语言编写，不受JVM管理）接口(Native)时候启用，即本地方法栈将会在每个线程创建的是将被分配内存 存储的是本地方法的数据 ​ 如上图的线程的start()方法创建时会调用一个native方法 异常行为 栈溢出：由于线程执行需要更大的栈而产生的异常，即线程过程执行需要存储大量内容而引起的 内存溢出：由于内存不足无法分配给栈而导致的异常 1.3 JVM Stacks 虚拟机栈每个Java虚拟机线程都有一个私有的Java虚拟机栈，JVM栈是运行的单位 生命周期：因栈是线程私有的，所以与线程的生命周期一致：随线程创建，随线程结束销毁 存储数据：Java虚拟机栈中存储栈帧：当前线程运行时所需要的局部变量、对象的引用、计算的结果、返回信息等 栈的行为：压入(push)和弹出(pop)栈帧 存取类型：压入和弹出栈帧采用FILO先进后出，因为是调用方法总是先完成。 Java虚拟机栈的内存不需要是连续的 JVM默认给每个栈分配的空间是1M，也可以自己在configurations中设置；所以如果分配给每个栈的内存越小，那么JVM所支撑的线程就越多 1.3.1 Frames 栈帧 存储数据： 局部变量表：基本数据类型、变量对象的引用（指针） 可操作数栈：方法执行过程中的结果 运行环境区：动态连接、方法返回相关信息、抛出异常 生命周期：每个方法都有一个栈帧，每次调用一个方法时就会创建一个栈帧，方法调用完后栈帧就被销毁，无论方法是否时正常结束或抛出异常。 局部变量与操作数栈的大小在编译时就确定了 当前栈：在线程运行时，仅有且只有一个正在运行的方法的栈帧；它对应的方法就是当前运行的方法，当前运行的类就是当前类。在局部变量和操作数栈上的操作是和当前栈帧相关的 栈帧会在方法调用另外一个方法或方法结束后停止。当一个方法被调用且控制权转为这个新的方法时，那么一个新的栈帧就会被创建成为当前栈帧。在方法返回时，当前栈帧就会将返回结果传递给调用者的栈帧（如果有的话）这个栈帧就会被之前的那个栈帧取代成为当前栈帧。 1.3.1.1 Local Variables 局部变量表 存储局部变量、对象的引用 一个单独的局部变量可以存储基本数据类型的值、引用，long和double型可以用两个局部变量来存储 局部变量使用索引来表示的，第一个局部变量的索引是0。一个整数可以当做一个索引，只要整数在[0，局部变量表的长度] 区域内。一个long、double类型的值占据两个连续的局部变量 虚拟机通过局部变量在方法调用过程中传递参数： 在类方法调用时，任何参数都在从局部变量0开始的连续局部变量中传递。 在实例方法调用中，局部变量0始终用于存储对调用实例方法的对象的引用（这在Java编程语言中）。 随后，任何参数都在从局部变量1开始的连续局部变量中传递。 1.3.1.2 operand stack 操作数栈 每个栈帧包含一个采用LIFO先进后出的操作数栈 存储执行过程中的结果：Java虚拟机提供指令，将局部变量或常量的值或内容加载到操作数栈上（不是局部变量和常量加载到操作数栈中） Java虚拟机指令从操作数栈中获取操作数，对它们进行操作，并将结果推回操作数栈中。例如：iadd指令将两个int值相加，于是将操作数栈的前两个int值相加，将结果压入栈中，并且两个int值都从操作数堆栈中弹出删除。 操作数栈具有相关联的深度：其中long或double类型的值占据两个单位深度，而其他类型的值占一个单位。 方法调用时可操作数栈与局部变量的互动 调用add()方法时创建add方法的栈帧 iconst_1 ：把int类型的1压入可操作数栈中 istore_1： 将可操作数栈中的int类型1存入局部变量表中的第一个位置：结果a＝1；同理，b=2 iload_1：将局部变量的第1、2个位置的数（即a、b的值）加载到操作数栈中 执行iadd加法：将1、2从栈中弹出相加，并将结果3压入栈中 istore_3 ：将int类型的3压入局部变量表中 iload_3：将局部变量的第3个位置的数（即c的值）加载到操作数栈中 return ：返回 1.3.1.3 Dynamic Linking 动态链接即多态：动态链接将抽象的引用转化为具体的引用 1.3.1.4 Normal Method Invocation Completion 方法正常结束 当被调用的方法执行到return返回指令时，必须返回适合的值类型（如果有的话） 当调用方法正常结束时： 当前帧用于恢复调用者的状态，包括其局部变量和操作数堆栈 调用者的程序计数器适当增加以跳过调用方法指令：比如调用者执行add()方法时是第9行，那么调用方法结束后PC+1，就变为第10行，这样调用者就会执行第10行的操作） 然后执行在调用方法的栈帧会将正常返回的值（如果有）压入该帧的操作数堆栈。 1.3.1.5 Abrupt Method Invocation Completion 方法异常结束 非正常结束的调用方法：抛出异常或错误 如果当前方法没有捕获到异常，则会导致方法调用突然结束。 这种方法结束调用时永远不会向其调用者返回值 讲完线程私有，接下来的就是线程共享的： 1.4 Heap 堆堆是存储的单位，栈是运行的单位 存储内容：记录所有实例对象和数组 生命周期：堆随虚拟机开始时创建 堆内存不连续 垃圾收集器管理的主要区域：当方法结束后，虚拟机栈会立即消失，而堆内存存储的对象的引用不会立即消失，而是等到gc进行回收 GC回收原则：当没有任何对象引用指向堆内存里面的对象时 从内存回收的角度来看，由于现在的收集器基本都采用分代收集算法，所以堆又可以细分成：新生代和老年代，新生代里面有分为：Eden空间、From Survivor空间、To Survivor空间。 默认情况下，新生代中Eden空间与Survivor空间的比例是8:1，可以使用参数-XX:SurvivorRatio对其进行配置。大多数情况下，新生对象在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，则触发一次Minor GC，将对象Copy到Survivor区，如果Survivor区没有足够的空间来容纳，则会通过分配担保机制提前转移到老年代去。 何为分配担保机制？在发送Minor GC前，JVM会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果是，那么可以确保Minor GC是安全的，如果不是，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果小于，直接进行Full GC，如果大于，将尝试着进行一次Minor GC，Minor GC失败才会触发Full GC。注：不同版本的JDK，流程略有不同。 Survivor区作为Eden区和老年代的缓冲区域，常规情况下，在Survivor区的对象经过若干次垃圾回收仍然存活的话，才会被转移到老年代。JVM通过这种方式，将大部分命短的对象放在一起，将少数命长的对象放在一起，分别采取不同的回收策略。 1.5 Method Area（meta space）方法区存放数据： 每个class的信息: 类名 字段信息 每个字段名字、类型(如类的全路径名、类型或接口) 、修饰符（如public、abstract、final）、属性 方法信息 每个方法的名字、返回类型、参数类型(按顺序)、修饰符、属性 运行时常量池：全局变量、所有常量、字段引用、方法引用、属性 方法代码 每个方法的字节码、操作数栈大小、局部变量大小、局部变量表、异常表和每个异常处理的开始位置、结 束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引 类加载器引用(classLoader) 方法区直接放在本地的物理内存（直接内存），其他的都放在JVM内存中 如果内存不足会报内存不足错误 1.5.1 Run-Time Constant Pool 运行时常量池方法区的一部分，存放在编译期间，就可以确定下来的值 字面量：如final、String及其包装类的值 1int a=1;//1就是字面量 符号引用：由于不知道所引用类的实际地址，而以符号的形式表现出来的 与直接引用不同，直接引用直接利用指针指向具体的实际地址 创建时间：当Java虚拟机创建类或接口时，将构造类或接口的运行时常量池；除了编译产生能存入，运行期间也能将新的常量放入池中(String.intern()) 节省内存空间：常量池中如果有对应的字符串，那么则返回该对象的引用，从而不必再次创建一个新对象。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
</search>
