<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TCP可靠传输的实现]]></title>
    <url>%2F2019%2F09%2F09%2FTCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[本文主要讲述TC保证可靠性的方式，并且采用哪些机制来保证可靠传输的，首先是TCP 保证可靠性的方式：1） 应用数据被分割成 TCP 认为最适合发送的数据块。2） 校验和：保持它首部和数据的校验和，确认数据的准确性。3）确认和重传机制：确认机制，发送报文后，等待确认；如果没有收到确认，将重发数据段。5）接收端会丢弃重复的数据6）发送端数据编号，接收端按序接收7）进行流量控制、拥塞控制一、确认与重传思想：发送报文后，等待对方的确认，如果收不到确认，则重传超时重传：发送报文后在超时计时器到期内还收不到该报文的确认，则重新发送该报文超时计时器的时间应当比报文平均的往返时间更长一些确认丢失：确认消息在传输过程丢失，重传该报文，接收端丢弃重复的报文并发送确认确认迟到：确认消息在传输过程中迟到，发送端丢弃迟到的确认（1）停止等待协议：为了实现可靠传输基本原理：每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；并且若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；自动重传请求ARQ：即上述的重传与确认机制，保证在不可靠的传输网络实现可靠的通信，简单但信道利用率低（2）连续ARQ协议(利用滑动窗口实现)基本原理：发送方可以连续发送分组，不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。优点：提高信道利用率，容易实现，即使确认丢失，也不必重传。缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。二、滑动窗口TCP的滑动窗口是以字节为单位的，并且可以动态变化的发送端的三种发送状态：已发送且收到确认的序号：发送窗口前面的序号（不再保留被删除）允许发送的序号：发送窗口里面的序号（已发送但未确认、可发送但未发送）未允许发送的序号：发送窗口后面的序号接收端的三种接受状态：已发送确认且并交付主机的数据允许接收的数据为允许接收的数据过程：发送端发送 发送窗口 中的数据，接收端按序接受数据并给出确认，如果数据没有按序到达（数据丢失），则接收端只能给出按序到达的数据中的最高序号给出确认，发送端要根据收到的确认号重传确认号后的数据（比如连续ARQ的例子）二、TCP的流量控制思想：让发送方的发送速率不要太快，让接收方来得及接受，因此发送方的发送窗口不能超过接受端的接受窗口的数值利用滑动窗口实现：滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。三、TCP 的拥塞控制主要是下面的四种机制：一、慢启动（慢开始）：发送方维持一个拥塞窗口（cwnd）的状态变量，拥塞窗口的大小取决于网络的阻塞程度，并且动态变化思路：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。为举例说明，这里使用报文段的个数作为拥塞窗口大小的单位（实际上拥塞窗口大小是以字节为单位的）过程：一开始发送方先设置 cwnd=1，发送第一个报文M1接收方收到后确认M1，发送方收到确认后，将cwnd从1增大为2发送方每收到一个对新报文的确认（重传不算在内）就使发送方的拥塞窗口加1，所以每经过一个传输轮次，拥塞窗口cwnd就加倍慢开始不是指 拥塞窗口cwnd 的增长速度慢（指数增长），而是指开始时cwnd=1一次传输轮次的时间=晚饭时间RTT=所有报文发送完毕并收到确认的时间为了防止 cwnd 增长过大引起网络拥塞，设置一个慢开始门限（ssthresh 状态变量）当 cnwd＜ssthresh，使用慢开始算法当 cnwd=ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法当 cnwd＞ssthresh，使用拥塞避免算法二、拥塞避免：思路：让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞控制窗口加1拥塞避免并非完全能够避免拥塞，而是cwnd按线性规律缓慢增加，比慢开始算法的倍数增长速率缓慢得多，使网络比较不容易出现拥塞无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为 1，执行慢开始算法。 如图所示：在TCP拥塞控制的文献中也成为“乘法减小”和”加法增加“，上述两种算法合起来就是AIMD算法三、快速重传：思路：快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量。四、快速恢复：当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半，为了避免网络发生拥塞。但是接下去并不执行慢开始算法。考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 的大小，然后执行拥塞避免算法。发送端有cwnd发送窗口，接收端也有rwnd接收窗口（通知窗口）发送端发送窗口的大小取决于网络拥塞程度，但接收端的缓存空间有限，所以接收端的接受窗口是根据自己的接受能力来设置的，并把这个窗口值写入TCP首部中的窗口字段，传送给发送方。因此，从接收方对发送方的流量控制的角度考虑，发送方的发送窗口一定不能超过对方给出的接收窗口值rwnd。即发送方窗口的上限值 = Min [ rwnd, cwnd ]当rwnd &lt; cwnd 时，是接收方的接收能力限制发送方窗口的最大值。当cwnd &lt; rwnd 时，则是网络的拥塞限制发送方窗口的最大值。也就是：rwnd和cwnd中较小的一个控制发送方发送数据的速率拥塞控制和流量控制的区别拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP的报文格式与连接]]></title>
    <url>%2F2019%2F09%2F09%2FTCP%E7%9A%84%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%E4%B8%8E%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[TCP是一个面向连接的、提供可靠传输的、全双工通信、面向字节流的传输层协议。本文先讲述TCP报文格式以及TCP连接的过程。TCP报文段首部格式源端口（2）： 数据发送方的端口号。目的端口（2）： 数据接受方的端口号。序号（4）：seq序号，记录本报文段所发送的第一个字节的序号。例如：一报文段字段值是301，携带数据共有100字节，因为在TCP连接中传送的字节流中的每一个字节都按顺序编号，所以本报文段的第一个字节的序号是301，最后一个字节的序号是400，那么下一个报文段应当从401开始确认号（4）：ack序号，即接收端希望收到的下一个数据报文中的第一个字节的序号。​ 只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。（上面例子里确认号=401）数据偏移（4位）：表示TCP报文段的数据起始处距离TCP报文段的起始处有多远（即TCP报文段的首部长度）数据偏移的单位是32bit，即4字节；因为4位二进制能够表是的最大十进制数是15，所以数据偏移的最大长度是15*4=60字节，除去固定部分的20字节，选项字段最大不能超过40字节保留（6位）紧急比特URG（1位）：当值为1时表示次报文段中有需要紧急处理。确认比特ACK（1位）：确认序号是否有效，为1时有效，为0时无效。TCP规定连接建立后传送报文段ACK=1推送比特PSH（1位）：接收方应该尽快将这个报文交给应用层。复位比特RST（1位）：重置连接，值为1时表示TCP连接存在严重的错误，需要重新进行连接。同步比特SYN（1位）：建立连接，在连接建立时同步序号，SYN=1时表示这是一个连接请求或连接接受报文当SYN=1且ACK=0时，表明这时一个连接请求报文段当SYN=1且ACK=1时，表明对方同意建立连接所以SYN=1时表示这是一个连接请求或连接接受报文终止比特FIN（1位）： 用于释放连接，值为1表示要发送的数据报已经发送完毕，需要释放传送连接。窗口字段（2）：接收端根据缓存空间的大小确定自己接受窗口的大小，限制发送放的窗口上限。检验和：用来检验首部和数据两部分的正确性。紧急指针字段：本报文紧急报文的最后一个字节的序号。需要注意的是：不要将确认序号ack与标志位中的ACK搞混了，确认方ack=发起方seq+1，两端配对。TCP的连接每一条TCP连接有两个端点，端点叫socket（套接字）socket是一个 五元组，包括：源IP、源端口、目的IP、目的端口、类型：TCP or UDP这个五元组，即标识了一条可用的连接。例如，本地IP是180.172.35.150，在浏览器中连接某一个Web服务器，例如百度，这条socket连接的五元组可能就是：[180.172.35.150:45678, tcp, 180.97.33.108:80]源IP为你的出口IP地址 180.172.35.150，源端口为随机端口 45678，目的IP为百度的某一个负载均衡服务器IP 180.97.33.108，端口为HTTP标准的80端口三次握手三次握手的过程：刚开始客户端处于 closed 的状态，服务端处于 listen 状态。然后1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号seq=X（seq利用ISN生成）。此时客户端处于 SYN_Send （同步已发送） 状态。2、第二次握手：服务器收到客户端的 SYN 报文后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号seq=Y，同时会把客户端的seq + 1 作为 Ack （确认序号）的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD（同步收到）的状态。3、第三次握手：客户端收到服务器 SYN 报文之后，会发送一个 ACK应答 报文，也是一样把服务器的seq + 1 作为 Ack 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。（此时客户端可以通过ACK报文段发送数据，但如果不发送数据则不消耗序号）4、服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方已建立连接三次握手的作用1、确认双方的接受、发送能力是否正常，是否可以传送数据。2、同步双方的初始化序列号，为后面的可靠传送做准备。3、协商窗口大小，同时接收方预留数据缓存区，为后面的可靠传送做准备。（ISN）是固定的吗三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。123ISN = M + F(localhost, localport, remotehost, remoteport)M是一个计时器，每隔4毫秒加1。F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。所以要保证hash算法不能被外部轻易推算得出。ISN是随机的，所以序列号容易就会超过2^31-1，就出现了“tcp序列号回绕”问题 参考博文四次挥手由于socket是全双工的工作模式，一个socket的关闭，是需要四次握手来完成的。四次挥手的过程：刚开始双方都处于 establised 状态，假如是客户端主动发起关闭请求（调用close()方法），则：1、第一次挥手：客户端发送一个 FIN 终止报文给服务器，报文中指定一个初始化序列号seq=U。此时客户端处于FIN_WAIT1状态。2、第二次挥手：服务端收到 FIN 之后，因为还有数据未发送完，所以服务器会先发送一个 ACK 应答报文，指定一个初始化序列号seq=V，且把客户端的序列号值seq + 1 作为确认序号的值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。客户端等待服务器关闭，则进入FIN_WAIT_2状态；此时，客户端 等待 服务器 发起关闭请求3、第三次挥手：服务器在完成所有数据发送后，主动发起关闭请求，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个初始化序列号seq=W。此时服务端处于 LAST_ACK 的状态。4、第四次挥手：客户端收到 FIN 之后，发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。等待2MSL（最长报文段寿命），主动关闭的一方，结束TIME-WAIT，进入CLOSED状态四次挥手的作用：确保数据能够完成传输，而不是发送FIN报文后对方立即关闭连接参考博文：关于3次握手与4次挥手TIME_WAIT的作用或2MSL的作用防止前一个连接上延迟的数据包或丢失重传的数据包，被后面复用的连接错误接收(异常:数据丢失或传输慢）SEQ=3的数据包丢失，重传第一次，没有得到ACK确认如果没有TIME_WAIT，或TIME_WAIT时间非常短，那么关闭的连接马上被重用，并连续发送SEQ=1,2 的数据包【180.172.35.150:45678, tcp, 180.97.33.108:80 的状态变为了CLOSED，源端口可被再次利用】【对180.97.33.108:80新建的连接，复用了之前的随机端口45678】此时，前面的连接上的SEQ=3的数据包再次重传，同时，seq的序号刚好也是3（这个很重要，不然，SEQ的序号对不上，就会RST掉），此时，前面一个连接上的数据被后面的一个连接错误的接收利用2MSL（最长报文段寿命）的等待时间，就可以**使本连接持续的时间内所产生的所有报文段都从网络中消失确保连接方能在时间范围内，关闭自己的连接（也是因为丢包导致的），即为了保证主动关闭方发送的最后一个ACK报文能够到达被动关闭方。总的来说就是为了解决网络的丢包和网络不稳定所带来的其他问题参考博文：你所不知道的TIME_WAIT]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM虚拟机]]></title>
    <url>%2F2019%2F08%2F31%2FJVM%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[讲述Java内存模型Java体系Java内存模型1. Run-Time Data Areas 运行时数据区JAVA虚拟机定义了各种用于程序执行时的运行时数据区：a) 一些数据区是与虚拟机的生命周期一致的：创建于虚拟机开始运行时，销毁于虚拟机退出时b) 一些数据区是与线程生命周期一致的：创建于线程创建，毁于线程推出在数据区中：线程私有：Program Counter Register、JVM Stacks、Native Method Stacks（无GC）线程共享：Heap、Method Area（有GC）1.1 Program Counter Register 程序计数器程序计数器是指CPU中的寄存器执行java方法时，程序计数器是有值的，存储的是当前执行的字节码指令的地址（保存下一条指令的所在存储单元的地址）CPU根据保存的指令地址找到指令，然后在执行。目的是防止多线程执行时出现干扰，单线程的话可以没有PC执行native本地方法时，程序计数器的值为空（Undefined）：因为native方法是java直接调用本地C/C++库进行实现，那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。程序计数器PC有足够的空间存储返回地址信息，占用的内存很小，所以PC是唯一一个JVM中没有OutOfMemoryError的区域。1.2 Native Method Stacks 本地方法栈作用场景：在程序调用或JVM调用本地方法（非java语言编写，不受JVM管理）接口(Native)时候启用，即本地方法栈将会在每个线程创建的是将被分配内存存储的是本地方法的数据​ 如上图的线程的start()方法创建时会调用一个native方法异常行为栈溢出：由于线程执行需要更大的栈而产生的异常，即线程过程执行需要存储大量内容而引起的内存溢出：由于内存不足无法分配给栈而导致的异常1.3 JVM Stacks 虚拟机栈每个Java虚拟机线程都有一个私有的Java虚拟机栈，JVM栈是运行的单位生命周期：因栈是线程私有的，所以与线程的生命周期一致：随线程创建，随线程结束销毁存储数据：Java虚拟机栈中存储栈帧：当前线程运行时所需要的局部变量、对象的引用、计算的结果、返回信息等栈的行为：压入(push)和弹出(pop)栈帧存取类型：压入和弹出栈帧采用FILO先进后出，因为是调用方法总是先完成。Java虚拟机栈的内存不需要是连续的JVM默认给每个栈分配的空间是1M，也可以自己在configurations中设置；所以如果分配给每个栈的内存越小，那么JVM所支撑的线程就越多1.3.1 Frames 栈帧存储数据：局部变量表：基本数据类型、变量对象的引用（指针）可操作数栈：方法执行过程中的结果运行环境区：动态连接、方法返回相关信息、抛出异常生命周期：每个方法都有一个栈帧，每次调用一个方法时就会创建一个栈帧，方法调用完后栈帧就被销毁，无论方法是否时正常结束或抛出异常。局部变量与操作数栈的大小在编译时就确定了当前栈：在线程运行时，仅有且只有一个正在运行的方法的栈帧；它对应的方法就是当前运行的方法，当前运行的类就是当前类。在局部变量和操作数栈上的操作是和当前栈帧相关的栈帧会在方法调用另外一个方法或方法结束后停止。当一个方法被调用且控制权转为这个新的方法时，那么一个新的栈帧就会被创建成为当前栈帧。在方法返回时，当前栈帧就会将返回结果传递给调用者的栈帧（如果有的话）这个栈帧就会被之前的那个栈帧取代成为当前栈帧。1.3.1.1 Local Variables 局部变量表存储局部变量、对象的引用一个单独的局部变量可以存储基本数据类型的值、引用，long和double型可以用两个局部变量来存储局部变量使用索引来表示的，第一个局部变量的索引是0。一个整数可以当做一个索引，只要整数在[0，局部变量表的长度] 区域内。一个long、double类型的值占据两个连续的局部变量虚拟机通过局部变量在方法调用过程中传递参数：在类方法调用时，任何参数都在从局部变量0开始的连续局部变量中传递。在实例方法调用中，局部变量0始终用于存储对调用实例方法的对象的引用（这在Java编程语言中）。 随后，任何参数都在从局部变量1开始的连续局部变量中传递。1.3.1.2 operand stack 操作数栈每个栈帧包含一个采用LIFO先进后出的操作数栈存储执行过程中的结果：Java虚拟机提供指令，将局部变量或常量的值或内容加载到操作数栈上（不是局部变量和常量加载到操作数栈中）Java虚拟机指令从操作数栈中获取操作数，对它们进行操作，并将结果推回操作数栈中。例如：iadd指令将两个int值相加，于是将操作数栈的前两个int值相加，将结果压入栈中，并且两个int值都从操作数堆栈中弹出删除。操作数栈具有相关联的深度：其中long或double类型的值占据两个单位深度，而其他类型的值占一个单位。方法调用时可操作数栈与局部变量的互动调用add()方法时创建add方法的栈帧iconst_1 ：把int类型的1压入可操作数栈中istore_1： 将可操作数栈中的int类型1存入局部变量表中的第一个位置：结果a＝1；同理，b=2iload_1：将局部变量的第1、2个位置的数（即a、b的值）加载到操作数栈中执行iadd加法：将1、2从栈中弹出相加，并将结果3压入栈中istore_3 ：将int类型的3压入局部变量表中iload_3：将局部变量的第3个位置的数（即c的值）加载到操作数栈中return ：返回1.3.1.3 Dynamic Linking 动态链接即多态：动态链接将抽象的引用转化为具体的引用1.3.1.4 Normal Method Invocation Completion 方法正常结束当被调用的方法执行到return返回指令时，必须返回适合的值类型（如果有的话）当调用方法正常结束时：当前帧用于恢复调用者的状态，包括其局部变量和操作数堆栈调用者的程序计数器适当增加以跳过调用方法指令：比如调用者执行add()方法时是第9行，那么调用方法结束后PC+1，就变为第10行，这样调用者就会执行第10行的操作）然后执行在调用方法的栈帧会将正常返回的值（如果有）压入该帧的操作数堆栈。1.3.1.5 Abrupt Method Invocation Completion 方法异常结束非正常结束的调用方法：抛出异常或错误如果当前方法没有捕获到异常，则会导致方法调用突然结束。 这种方法结束调用时永远不会向其调用者返回值讲完线程私有，接下来的就是线程共享的：1.4 Heap 堆堆是存储的单位，栈是运行的单位存储内容：记录所有实例对象和数组生命周期：堆随虚拟机开始时创建堆内存不连续垃圾收集器管理的主要区域：当方法结束后，虚拟机栈会立即消失，而堆内存存储的对象的引用不会立即消失，而是等到gc进行回收GC回收原则：当没有任何对象引用指向堆内存里面的对象时从内存回收的角度来看，由于现在的收集器基本都采用分代收集算法，所以堆又可以细分成：新生代和老年代，新生代里面有分为：Eden空间、From Survivor空间、To Survivor空间。默认情况下，新生代中Eden空间与Survivor空间的比例是8:1，可以使用参数-XX:SurvivorRatio对其进行配置。大多数情况下，新生对象在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，则触发一次Minor GC，将对象Copy到Survivor区，如果Survivor区没有足够的空间来容纳，则会通过分配担保机制提前转移到老年代去。何为分配担保机制？在发送Minor GC前，JVM会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果是，那么可以确保Minor GC是安全的，如果不是，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果小于，直接进行Full GC，如果大于，将尝试着进行一次Minor GC，Minor GC失败才会触发Full GC。注：不同版本的JDK，流程略有不同。Survivor区作为Eden区和老年代的缓冲区域，常规情况下，在Survivor区的对象经过若干次垃圾回收仍然存活的话，才会被转移到老年代。JVM通过这种方式，将大部分命短的对象放在一起，将少数命长的对象放在一起，分别采取不同的回收策略。1.5 Method Area（meta space）方法区存放数据：每个class的信息:类名字段信息每个字段名字、类型(如类的全路径名、类型或接口) 、修饰符（如public、abstract、final）、属性方法信息每个方法的名字、返回类型、参数类型(按顺序)、修饰符、属性运行时常量池：全局变量、所有常量、字段引用、方法引用、属性方法代码每个方法的字节码、操作数栈大小、局部变量大小、局部变量表、异常表和每个异常处理的开始位置、结 束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引类加载器引用(classLoader)方法区直接放在本地的物理内存（直接内存），其他的都放在JVM内存中如果内存不足会报内存不足错误1.5.1 Run-Time Constant Pool 运行时常量池方法区的一部分，存放在编译期间，就可以确定下来的值字面量：如final、String及其包装类的值1int a=1;//1就是字面量符号引用：由于不知道所引用类的实际地址，而以符号的形式表现出来的与直接引用不同，直接引用直接利用指针指向具体的实际地址创建时间：当Java虚拟机创建类或接口时，将构造类或接口的运行时常量池；除了编译产生能存入，运行期间也能将新的常量放入池中(String.intern())节省内存空间：常量池中如果有对应的字符串，那么则返回该对象的引用，从而不必再次创建一个新对象。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
</search>
