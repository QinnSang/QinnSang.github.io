<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试常见的：String是否相等 问题原理探究]]></title>
    <url>%2F2019%2F09%2F18%2F%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E7%9A%84%EF%BC%9AString%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89-%E9%97%AE%E9%A2%98%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[比较两个String对象是否相等的问题在笔试中常会碰到，但是一直没有理清它们究竟为什么相等，为什么不相等，今天终于把这个整理了一遍。首先，本文基于以下博主的参考博文总结，非常感谢他们。https://www.zhihu.com/question/55994121https://mp.weixin.qq.com/s/nWswsWKiSDEv4734VVUKkghttps://juejin.im/post/5b3197c4e51d4558b70cae46三个常量池Class文件中的常量池：存放字面量和符号引用，（用双引号引起来的字符串字面量都会进这里面）运行时常量池：存放在方法区中。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池(Constant Pool Table)，存放编译期生成的各种字面量和符号引用，常量池这部分的内容将在类加载后进入方法区的运行时常量池。全局字符串常量池：存放在堆中。HotSpot VM里，记录interned string的一个全局表叫做StringTable，它本质上就是个HashSet。注意它只存储对java.lang.String实例的引用，而不存储String对象的内容。因为是HashSet，所以不会保存相同的引用，所以字符串加载时会先判断字符串常量池中是否存储对堆中该字符串的引用，如果没有才在堆中创建字符串对象，并将其引用放入字符串常量池中；如果有则不加入举例说明：1String s1="Java";//“Java”就是字符串字面量编译期：将双引号里的字符串字面量“Java”（无论是否在new String(“Java”)里）和符号引用s1加载到Class文件的常量池中类加载期：字面量和符号引用 加载到 运行时常量池中，但是字面量“Java”不一定会进入字符串常量池中，需要判断，如果存在则不进入，那这里“Java”不存在在字符串常量池中，所以就创建、保存引用、返回例1123String s1="Java";//语句1String s2=new String("Java");//语句2System.out.println(s1==s2);//false：因为s1指向的是字符串常量中的引用，s2是堆内存中对象的引用语句1和语句2都是创建一个字符串对象，但是有区别：语句1：s1保存的就是字符串常量池对“Java”字符串对象的引用语句2：new String(“Java”)先在字符串常量池中查找有没有该“Java”的引用，若没有则在堆内存中创建“Java”，而后通过new在堆内存中创建new String()对象，把“Java”拷贝赋值。那这里常量池中已经有了”Java”，就不用创建“Java”字符串对象了，只需创建new String()对象即可所以此时创建堆内存一个对象，new String()和”Java“堆内存的地址值不一样如果问String s = new String(&quot;Java&quot;);创建了几个对象？：1或2个对象，看字符串常量池是否有对堆内存的“Java”字符串对象的引用例2123String s1=new String("Java");//语句1：在堆中创建了new String("Java") 字符串对象String s2=new String("Java");//语句2：在堆中创建了new String("Java") 字符串对象System.out.println(s1==s2);//false原因：语句1与语句2 创建的字符串对象在堆内存的地址不一样，所以s1、s2不是指的一块堆内存地址，所以为false例312345 String s2 = new String("Java"); //语句1s2.intern();//语句2，注意没有接收intern的返回值String s1 = "Java"; //语句3 System.out.println(s1 == s2);//false：s1是字符串常量池的对堆内存中字符串字面量的引用先介绍什么是intern方法：如果字符串常量池中存在当前字符串的引用，那么直接返回字符串常量池中它的引用如果字符串常量池中没有此字符串的引用，说明堆中还没有该对象，就会先去堆中创建该对象，并将此字符串引用保存到字符串常量池中后, 再直接返回该字符串的引用！那对于语句2：intern() 发现字符串常量池中有“Java”字符串对象，返回该引用即可，注意没有接收返回的引用s1指向的是堆内存new String()对象的地址，而s2指向的是字符串常量池对堆内存的“Java”字符串对象的引用，所以s1==s2返回false例4123456String s1 = "Java"; //语句1String s2 = new String("Java"); //语句2String s3 = new String("Java").intern();//语句3System.out.println(s1 == s3);//返回true //因为s3是字符串常量池的对堆内存中字符串字面量的引用System.out.println(s2 == s3);//返回false“+”加号用法例5+号右边都是字符串字面量的，编译器在编译期就会将字符串字面量拼接在一起，所以s1存储的是字符串常量池中对堆内存中的“abc”字符串对象的引用123String s1 = "ab" + "c";String s2 = "abc";System.out.println(s1 == s2);//true例6+号右边 不全是字符串字面量的，至少有一个是对象的，那么+号是使用底层的StringBuilder对象，一路append，最后调用StringBuilder对象的toString方法得到一个String对象，并把它赋值给符号引用注意：这个toString方法会new一个String对象1234 String s1 = new String("Ja")+new String("va");//语句1s1.intern();//语句2，注意没有接受intern的返回值String s2 = "Java";//语句3 System.out.println(s1 == s2); //返回true语句1：字符串常量池中没有“Ja”、“va”字符串字面量的堆引用，先创建这两个字面量，然后将引用保存到字符串常量池中；然后 +号：创建一个new String(“Java”)，注意：没有把Java的引用放入字符串常量池此时堆中一共有三个对象：new String(“Ja”)、new String(“va”)、new String(“Java”)语句2：intern会去查找字符串常量池中是否有“Java”这个堆引用，发现没有，就将new String(“Java”)字符对象的引用保存到字符串常量池中，并返回当前字符串的引用(但没有接收)语句3：发现字符串常量池已经存在引用了，直接返回(拿到的也是与s1相同指向的引用)结果：因为s1、s2指向的都是new String(“Java”)这个对象，所以返回true]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的前中后序层次遍历（递归、迭代、莫里斯算法）]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E3%80%81%E8%BF%AD%E4%BB%A3%E3%80%81%E8%8E%AB%E9%87%8C%E6%96%AF%E7%AE%97%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[有两种通用的遍历树的策略：深度优先搜索（DFS）：从根开始一直到达某个确定的叶子，然后再返回根到达另一个分支。深度优先搜索策略又可以根据根节点、左孩子和右孩子的相对顺序被细分为前序遍历，中序遍历和后序遍历。一般用栈来实现宽度优先搜索（BFS）：我们按照高度顺序一层一层的访问整棵树，高层次的节点将会比低层次的节点先被访问到。一般用队列来实现前序遍历（根-左-右）递归版本123456789101112List &lt; Integer &gt; res = new ArrayList &lt;&gt; ();public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; if(root!=null)&#123; res.add(root.val); if(root.left!=null) preorderTraversal(root.left); if(root.right!=null) preorderTraversal(root.right); &#125; return res;&#125;迭代算法版本1因为栈是先进后出，所以先入右结点后入左结点12345678910111213141516171819public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (root == null) &#123; return res; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); res.add(node.val); if (node.right != null) &#123; stack.push(node.right); &#125; if (node.left != null) &#123; stack.push(node.left); &#125; &#125; return res;&#125;迭代算法版本2123456789101112131415public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List &lt; Integer &gt; res = new ArrayList &lt;&gt; (); Stack &lt; TreeNode &gt; stack = new Stack &lt;&gt; (); TreeNode curr = root; while (curr != null || !stack.isEmpty()) &#123; while (curr != null) &#123; res.add(curr.val); stack.push(curr); curr = curr.left; &#125; curr = stack.pop(); curr = curr.right; &#125; return res;&#125;莫里斯遍历先看中序遍历的莫里斯遍历Step 1: 将当前节点current初始化为根节点Step 2: While current不为空①若current没有左子节点a. 将current添加到输出b. 进入右子树，亦即, current = current.right②否则进入current的左子树中，找到“右子节点为空或者即使不为空也要不等于当前节点”的最右侧节点​ 如果最右侧结点为空，说明不是因为最右侧结点已经建立后继节点而退出while循环的​ a. 将当前节点输出，并设置最右侧节点的右子节点（后继节点）为current​ b. 进入左子树，亦即，current = current.left​ ③如果最右侧结点的右子节点即后继节点已经指向current​ a. 将最右侧节点的右子节点置空（恢复树结构，避免死循环）​ b. 进入右子树123456789101112131415161718192021222324252627public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; LinkedList&lt;Integer&gt; output = new LinkedList&lt;&gt;(); TreeNode node = root; while (node != null) &#123; if (node.left == null) &#123; output.add(node.val); node = node.right; &#125; else &#123; TreeNode predecessor = node.left; while ((predecessor.right != null) &amp;&amp; (predecessor.right != node)) &#123; predecessor = predecessor.right; &#125; if (predecessor.right == null) &#123; output.add(node.val); predecessor.right = node; node = node.left; &#125; else&#123; predecessor.right = null;//恢复树结构，避免死循环 node = node.right; &#125; &#125; &#125; return output;&#125;参考LeetCode上的前序遍历的官方解答中序遍历（左-根-右）递归版本123456789101112List &lt; Integer &gt; res = new ArrayList &lt;&gt; ();public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; if(root!=null)&#123; if(root.left!=null) inorderTraversal(root.left); res.add(root.val); if(root.right!=null) inorderTraversal(root.right); &#125; return res;&#125;迭代算法版本212345678910111213141516//若返回途中有右子树，则遍历该右子树，重复操作 public List &lt; Integer &gt; inorderTraversal(TreeNode root) &#123; List &lt; Integer &gt; res = new ArrayList &lt; &gt; (); Stack &lt; TreeNode &gt; stack = new Stack &lt; &gt; (); TreeNode curr = root; while (curr != null || !stack.isEmpty()) &#123; while (curr != null) &#123; stack.push(curr); curr = curr.left; &#125; curr = stack.pop(); res.add(curr.val); curr = curr.right; &#125; return res; &#125;莫里斯遍历原理：线索二叉树实现方法：12345678Step 1: 将当前节点current初始化为根节点Step 2: While current不为空 ①若current没有左子节点 a. 将current添加到输出 b. 进入右子树，亦即, current = current.right ②否则 a. 在current的左子树中，令current成为最右侧节点的右子节点 b. 进入左子树，亦即，current = current.left对应代码：123456789101112131415161718192021public List &lt; Integer &gt; inorderTraversal(TreeNode root) &#123; List &lt; Integer &gt; res = new ArrayList &lt; &gt; (); TreeNode curr = root; TreeNode pre; while (curr != null) &#123; if (curr.left == null) &#123; res.add(curr.val); curr = curr.right; // 进入右子树 &#125; else &#123; // 如果存在左子树 pre = curr.left; while (pre.right != null) &#123; // 找到左子树下的最右结点 pre = pre.right; &#125; pre.right = curr; // 将最右结点的右子结点指向当前结点 TreeNode temp = curr; // store cur node curr = curr.left; // 进入左子树 temp.left = null; // original cur left be null, avoid infinite loops &#125; &#125; return res; &#125;参考LeetCode官方的解答中序遍历后序遍历（左-右-根）递归版本123456789101112List &lt; Integer &gt; res = new ArrayList &lt;&gt; ();public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; if(root!=null)&#123; if(root.left!=null) postorderTraversal(root.left); if(root.right!=null) postorderTraversal(root.right); res.add(root.val); &#125; return res;&#125;迭代算法版本1前序遍历顺序为：根 -&gt; 左 -&gt; 右后序遍历顺序为：左 -&gt; 右 -&gt; 根假设1： 将前序遍历顺序由从左到右修改为从右到左那么结果链表就变为了：根 -&gt; 右 -&gt; 左假设2： 在假设1的前提下，将前序遍历中节点插入结果链表尾部的逻辑，修改为将节点插入结果链表的头部那么结果链表就变为了：左 -&gt; 右 -&gt; 根这刚好是后序遍历的顺序代码实现：1234567891011121314public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(root == null) return res; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); stack.push(root); while(!stack.isEmpty())&#123; TreeNode node = stack.pop(); if(node.left != null) stack.push(node.left);//和传统先序遍历不一样，先将左结点入栈 if(node.right != null) stack.push(node.right);//后将右结点入栈 res.add(0,node.val); //逆序添加结点值 &#125; return res;&#125;迭代算法版本212345678910111213141516171819202122232425public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); if(root ==null) return list; TreeNode visitedRight=null; Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); while(root!=null || !stack.isEmpty())&#123; while(root!=null)&#123; stack.push(root); root=root.left; &#125; root=stack.peek();//while循环退出说明栈顶的是该子树的最左节点 // 在不存在右节点或者右节点已经访问过的情况下，访问根节点 if(root.right == null || root.right == visitedRight)&#123; list.add(root.val); stack.pop(); visitedRight=root; root=null; &#125; else&#123; root=root.right; &#125; &#125; return list;&#125;莫里斯算法结合 后序的迭代算法版本1 与 前序的莫里斯遍历 的思想12345678910111213141516171819202122232425262728public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList(); TreeNode node = root; TreeNode predecessor; while (node != null) &#123; if (node.right == null) &#123; result.add(0, node.val); node = node.left; &#125; else &#123; predecessor = node.right; while (predecessor.left != null &amp;&amp; predecessor.left != node) predecessor = predecessor.left; if (predecessor.left == null) &#123; result.add(0, node.val); predecessor.left = node; node = node.right; &#125; else &#123; predecessor.left = null; node = node.left; &#125; &#125; &#125; return result;&#125;参考LeetCode解答层次遍历（BFS 队列）不分行打印12345678910111213public static void BFSOrder(TreeNode root) &#123; if(root==null) return ; Queue&lt;TreeNode&gt; q=new LinkedList&lt;&gt;(); q.add(root); while(!q.isEmpty())&#123; TreeNode n=q.poll(); System.out.print(n.val+" "); if(n.left!=null) q.add(n.left); if(n.right!=null) q.add(n.right); &#125; &#125;分行打印需记录每层的节点数12345678910111213141516171819202122public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; l=new ArrayList&lt;&gt;(); if (root == null) return l; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); while (!q.isEmpty()) &#123; List&lt;Integer&gt; ll = new ArrayList&lt;&gt;(); int size = q.size();//记录当前层的节点数 while (size-- &gt; 0) &#123; TreeNode n = q.poll(); ll.add(n.val); if (n.left != null) q.add(n.left); if (n.right != null) q.add(n.right); &#125; // 从下往上遍历只需要把每一层得到的结果都方到list的头部！！ l.add(0,ll); &#125; return l; &#125;LeetCode的层次遍历]]></content>
      <categories>
        <category>算法记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据链路层简述（一）]]></title>
    <url>%2F2019%2F09%2F11%2F%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%AE%80%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文简述一下数据链路层主要涉及的知识点，只是作为一个整理，暂时不作详解，未提到的知识点后续会再整理发布。任务及必要性封装成帧：帧是数据链路层的传送单元：将网络层交付下来的IP数据报（分组）的前后添加首部和尾部，封装成帧。首部和尾部的重要作用是进行帧定界。帧定界是分组交换的必然要求。透明传输：避免消息字符与帧定界字符（SOH、EOT）相混淆，在数据中出现控制字符前插入ECS转移字符，达到无论什么比特组合的数据都可通过数据链路层差错检验：为了保证数据传输的可靠性，在传输数据时，必须采用差错检测措施。目前广泛运用的是循环冗余检验CRC以太网（MAC）帧以太网帧由前导码、本体构成前导码：由前同步码与帧开始定界符构成，前同步码用于同步两端时间，实现“位同步”（即比特同步）本体：由首部，数据和 FCS 三部分组成类型：存储上层协议的编号，告诉以太网数据帧携带的是什么数据。对于ARP来说这两个字节是0x0806，对于IP数据报是0x0800，还有RARP（逆地址解析协议）是0x8035FCS 是帧校验序列（使用CRC检验）：用于判断帧是否在传输过程中有损坏(比如电子噪声干扰)循环冗余检验CRC基本思想：将传输的数据除以“生成多项式”，得到的余数作为校验数据附加到原数据后面。举例说明：假定待传输的数据M = 101001(k = 6)，除数p = 1101（n=3，为什么=3后面讲）进行模2运算，即(2^n)乘M的运算,相当于在M后面添加n个0，即M后面添加3个0现在M = 101001000(k+n = 9)位的数除以除数p(n = 3)位，得到商是Q(不关心)，余数R =001（n位）R就是冗余码FCS，将R添加到原数据后即可接受端对收到的数据再次进行CRC检验，方法就是把收到的每一帧都除以相同的除数，然后检查得到的余数。余数为0，则正确，接收这个帧；余数不为0，帧有问题，丢弃帧为什么除数取1101？在CRC算法中，这个被除数也叫做“生成多项式”。生成多项式的选取是个很有难度的问题，如果选的不好，那么检出错误的概率就会低很多。所以对于使用者来说，只要把现成的成果拿来用就行了。12345CRC8=X8+X5+X4+X0CRC-CCITT=X16+X12+X5+X0CRC16=X16+X15+X2+X0CRC12=X12+X11+X3+X2+X0CRC32=X32+X26+X23+X22+X16+X12+X11+X10+X8+X7+X5+X4+X2+X1+X0为什么n=3？n在CRC里面称为“位宽”，并且不是多项式对应的二进制数的位数，而是多项式位数减1。比如上述例子中的多项式是1101，那么n=其位数-1=4-1=3，按照CRC算法的要求，计算前要在原始数据后填上n个0，也就是3个0参考博文MTU最大传输单元数据链路层允许的IP数据报的长度（一般最小64字节，最大1500字节），每种数据链路的最大传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。数据链路层的最小MTU 为 64 字节：因为需要做碰撞检测碰撞检测：以太网发送数据时，如果在争用期内没有发生碰撞，那么后续发送的数据就一定不会发生冲突，如果发生碰撞，一定是在发送的前64字节之内，由于检测到冲突后会中止发送，所以发送的数据一定小于64字节，因此凡长度小于64字节的帧都是由于冲突而异常终止的无效帧，收到后立即丢弃。为什么争用期（冲突窗口）为51.2us呢？在极限条件下，一个局域网中两个站点（4个中继器连接）的最大距离为2500m，往返5000m，电缆的传播时延为5us/km，即如遇冲突，端到端往返时延为25us。然而这是理想的时延，考虑到中继器的额外时延，最坏情况下取估计时延为45us，再加上强化冲突需发送48bit，接受方要接受到48bit后才确认冲突，即在增加4.8us，共49.8us，所以通常以太网取51.2us为争用期的时间长度参考博文为什么是64字节呢因为争用期是51.2us，对于 10Mbps 的 以太网来说，其这个时间等于发送 64 字节，即 512（10*51.2） 位的时间，所以可以在64字节之内检测到冲突。传输时延是指一个站点从开始发送数据帧到数据帧发送完毕所需要的全部时间，传播时延是指发送端开始发送数据到接收端收到数据所需要的全部时间。数据链路层的最大 MTU 为 1500 字节，即数据字段的最大长度较小长度的帧传输效率又不高，较大的帧占用共享链路时间过长，影响其它主机的通信，然后通过多次试验选择了一个折衷的长度：1518字节，对应的MTU就是1500字节。参考博文IEEE 802．3又叫做具有CSMA/CD(载波监听多路访问/冲突检测)的网络。CSMA/CD是IEEE802．3采用的媒体接入控制技术，或称为介质访问控制技术。载波监听：发送前或发送中检测信道是否有其他站在发送数据多路访问：总线型网络，计算机以多点接入的方式连接在一条总线上冲突检测：发送中载波监听就是冲突检测]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网</tag>
        <tag>数据链路层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络层之ICMP协议简述]]></title>
    <url>%2F2019%2F09%2F10%2F%E7%BD%91%E7%BB%9C%E5%B1%82%E4%B9%8BICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[为了更有效转发IP数据报和提高交付成功的机会，在网络层使用了ICMP 网际控制报文协议。ICMP允许主机或路由器报告差错或提供一些需要注意的信息。ICMP层次ICMP 一般认为是三层的，ICMP报文不是高层协议，而是作为IP层数据报的数据ICMP 报文分类ICMP 分为两类，一类是 ICMP 查询报文，另一类是 ICMP 差错报文。ICMP差错报文：（1）终点不可达报文：当路由器或主机给该数据报寻路时，没有找到相应路径，不能交付数据报时，向源 IP 发回 ICMP 主机不可达（2）源点抑制：路由器或主机因网络拥塞而丢弃数据报时，就向源点发送源点抑制报文，让源点到那时速率放慢（3）时间超时：收到TTL生存时间为0的数据报或终点在规定时间内没有完全收到某个数据报时，就向源点发送时间超时报文（4）参数问题：路由器户或主机收到的数据报的首部字段值不正确时，丢弃该数据报后向源点发送参数问题报文（5）重定向（改变路由）差错报文：当一个路由器知道通向目的网络的最佳路由时，会用重定向报文告诉主机，这样，主机再一次发送数据报时不会发送到之前的路由，而是发送给最佳路由。举个例子：1） 主机发送 IP 数据报给 R1，因为主机的默认路由指向的下一跳是 R1。2） R1 收到数据报并且检查它的路由表，发现 R2 是发送该数据报的下一跳。当他将数据报发送给 R2 的时候，发现发送的接口与接受的端口是一样的，因此同时发送一个 ICMP 重定向报文给主机。3） 主机接受到 ICMP 重定向报文后，接下来的数据报就发送给 R2，而不再发送给 R1。重定向报文有什么规则？重定向报文只能有路由器生成。重定向报文是为主机而不是为路由器使用的什么情况不会导致产生 ICMP 差错报文？1）对于ICMP差错报文不产生ICMP差错报文2） 目的地址是广播地址或者多播地址的 IP 数据报。3） 数据报分片不是第一个分片的数据报片，都不发送ICMP差错报告报文4） 源地址不是单个主机的数据包。Ping 命令的具体过程是怎么样的？Ping是利用ICMP协议包来侦测另一个主机是否可达通过ARP寻找目的主机的MAC地址用类型码为0的ICMP查询报文发请求，受到请求的主机则用类型码为8的ICMP查询报文回应这样就完成了同一网段内的ping过程参考文章：《对于 Ping 的过程，你真的了解吗？》]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网</tag>
        <tag>ICMP</tag>
        <tag>网络层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络层之IP协议]]></title>
    <url>%2F2019%2F09%2F10%2F%E7%BD%91%E7%BB%9C%E5%B1%82%E4%B9%8BIP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[网络层的协议：网际协议IP，首先需要了解网络主要的设计思路与实现的服务：网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据传输服务。发送分组时不需要先建立连接。每一个分组独立发送，与其前后的分组无关（不进行编号）。网络层不提供可靠传输，使得路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。主机中的进程通信的可靠性由运输层的TCP协议来负责采用这种设计思路的好处是：网络的造价大大降低，运行方式灵活，能移适应多种应用。IP网际协议IP协议提供了一种不可靠、无连接的数据传输服务，作用于主机：1、不可靠：不能保证IP数据报能成功到达目的地；发生错误会直接丢弃该数据报，然后发送ICMP消息给信源端；2、无连接：传送IP数据报（分组）前不需要要建立连接，每一个分组独立发送，与其前后的分组无关（不进行编号）IP数据报格式版本号（4）： IPV4 就是 4，IPV6 就是 6首部长度（4）：记录IP数据报首部的长度，首部最小长度为20字节，最大为60字节以4 个字节为单位：每行32bit，即4个字节(首部长度不是4字节的整数倍，必须在填充字段加以填充)最小值为 5：仅有固定部分，可变部分为0，固定部分有5行，即1001。最大值为 15：首部长度为4bit，而2^4是16，所以它的取值范围是0-15，即1111所以最小长度=54= 20 个字节，最大=15*4= 60个字节。服务类型（8）： Qos 用，目前不怎么使用。（8）总长度（16）：首部+数据部分的长度，以字节为单位。 最多可以传送 2^16^-1=165535 字节的 IP 数据包【为什么 IP 首部中要有总长度字段】因为一些数据链路（以太网）有MTU最大传输单元】限制，小于最小MTU需要填充一些数据以达到最小长度，大于最大MTU需要对数据报进行分片处理，所以需要总长度来确定 IP 数据部分的内容。标识字段（8）：唯一标识主机发送的每一份数据报，具有相同标识的数据报片属于同一个数据报标志 （3）：R、DF、MF三位。目前只有后两位有效DF位：为1表示不分片，为0表示分片MF：为1表示“更多的片”，为0表示这是最后一片片偏移（13bit）：标识被分片的每一个报片相对于原始数据的位置，第一个分片对应的值为0。【分片处理举例】IP数据包数据部分长度为3200位，首部为160位，MTU为1200，则发送数据报必须分片因为首部为160，所以分片后传输的数据部分长度最大为1040数据报总长度标识MFDF片偏移原始数据报3200+160123000数据报片11040+160=1200123100数据报片21040+160=1200123101040/8=130数据报片31040+160=1200123101040/8+130=260数据报片480+160=2401230080/8+260=270生存时间 TTL（8）：经过一个路由器减一。 字段为 0 时，数据报被丢弃，并且发送 ICMP 报文通知源主机。目的是防止数据报在选路时无休止地在网络中流动。协议（8）：区分上层协议（ 目标端根据协议把收到的IP数据报送到TCP或UDP等处理此报文的上层协议)首部校验和（16）：仅对首部进行校验【首部校验和计算方法】先把校验和字段置 0。对首部中每组 16 位比特多多组进行二进制反码求和。结果存在检验和字段中。接收端 收到一份 IP 数据包后，同样对首部中每个 16bit 二进制反码求和。最后结果全为 1，表示正确，否则表示错误。如果是错误的，IP 就丢弃该数据报，但是不生成差错报文，由上层去处理。【对比： ICMP，IGMP，TCP，UDP：对首部和数据进行校验】共同点：用到的算法都是一样的。区别：IP 计算的时候没有将数据包括在内，ICMP，IGMP，TCP，UDP 同时对首部和数据进行检验源地址（32）：发送端IP地址目的地址(32)：接收端IP地址IP地址IP地址由[网络号，主机号]组成，在网络号字段前会有1~3的类别位IP地址的指派范围：网络类别网络号范围最大可指派的网络数最大主机数A 类地址1.0.0.1~~126.255.255.2542^7^-2(保留地址全0+127环回)=1262^24^-2=16777214B 类地址128.0.0.1~~191.255.255.2542^14^-1(128.0.0.0)=163832^16^-2=65534C 类地址192.0.0.1~~223.255.255.2542^21^-1(192.0.0.0)=20971512^8^-2=254D 类地址224.0.0.1~~239.255.255.254主机数-2：全0的本主机，全1的所有主机E 类地址240.0.0.1~~254.255.255.254IP地址的特点：(1) 每个IP地址由网络号与主机组成（分等级的地址结构），好处是：①网络号由IP管理机构管理，而主机号由得到该网络号的单位自行分配；②路由器仅根据目的主机所连接的网络号转发分组，减小路由表的存储空间以及查找路由表的时间(2) 一个网络是具有相同网络号的主机的集合，因此，用转发器或网桥连接的若干个局域网仍是一个网络，具有不同网络号的局域网必须使用路由器进行互连(3) IP地址实际上是标志一个主机（或路由器）和一条链路的接口，如果一个主机同时连接到两个网络，那么主机必须有两个ip地址，这种主机就是多归属主机。由于路由器至少连接两个不同的网络，因此一个路由器至少有两个不同的IP地址直接交付与间接交付：当源主机向目的主机发送数据报时，先要检查目的主机是否与源主机连接在同一个网络上：如果是，就将数据报直接交付给目的主机B而不需要通过路由器；如果不是，则应该将数据报发送给本网络上的某个路由器，由该路由器进行转发，这叫做间接交付。主机和路由器本质区别主机从不把数据报从一个接口转发到另一个接口，而路由器则要转发数据报。IP 路由选择IP路由选择其实是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组。特性：（１） IP 路由选择是逐跳进行的。IP 路由表并不知道到达目的的完整路径，只提供下一跳地址。（２） 为一个网络指定一个路由器，而不是为每个主机指定一个路由器。这样可以缩小路由表规模。过程（简单版）：根据最长匹配原则，找到条目，发送到指定的路由器或主机。如果不能找到，返回一个“主机不可达”或“网络不可达”的错误。IP 搜索路由表的步骤（详细版）从IP数据报首部提取目的IP地址根据最长匹配原则，首先搜索匹配的网络地址，如果找到则直接将数据报交付给条目中所对应的的网络接口如果找不到，则搜索匹配的网络号，如果找到，则间接交付给条目中对应的下一站路由器，由该路由器进行分组转发如果还找不到，就搜索默认选项，由默认选项中的下一站路由器进行分组转发如果路由表中没有默认项，而又没有找到匹配项，则结果取决于该 IP 数据报是由主机产生的还是被转发的如果数据报是由本机产生的，那么就给发送该数据报的应用程序返回一个“主机不可达差错”或者是“网络不可达差错”的差错报文。如果是被转发的数据报，就给源主机发送一份“主机不可达”的差错报文。附加补充：路由选路原则：先进行最长匹配原则，满足后进行管理距离最小优先，依旧满足进行度量值最小优先A: 最长匹配原则：最长匹配原则是CISCO IOS路由器默认的路由查找方式。当路由器收到一个IP数据包时，会将数据包的目的IP地址与自己本地路由表中的表项进行bit by bit的逐位查找，直到找到匹配度最长的条目，这叫最长匹配原则。B: 管理距离AD最小优先：可以是多种路由协议的比较；也可以是同种路由协议的比较，比如双线出口所配置的两条默认浮动路由比较C：度量值metric最小优先：路由协议不同则度量值不能做比较，比如rip度量值为跳数；ospf度量值为带宽；eigrp度量值为带宽+延迟等。所以在不同种协议之间先比较管理距离]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP可靠传输的实现]]></title>
    <url>%2F2019%2F09%2F09%2FTCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[本文主要讲述TC保证可靠性的方式，并且采用哪些机制来保证可靠传输的，首先是TCP 保证可靠性的方式：1） 应用数据被分割成 TCP 认为最适合发送的数据块。2） 校验和：保持它首部和数据的校验和，确认数据的准确性。3）确认和重传机制：确认机制，发送报文后，等待确认；如果没有收到确认，将重发数据段。5）接收端会丢弃重复的数据6）发送端数据编号，接收端按序接收7）进行流量控制、拥塞控制一、确认与重传思想：发送报文后，等待对方的确认，如果收不到确认，则重传超时重传：发送报文后在超时计时器到期内还收不到该报文的确认，则重新发送该报文超时计时器的时间应当比报文平均的往返时间更长一些确认丢失：确认消息在传输过程丢失，重传该报文，接收端丢弃重复的报文并发送确认确认迟到：确认消息在传输过程中迟到，发送端丢弃迟到的确认（1）停止等待协议：为了实现可靠传输基本原理：每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；并且若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；自动重传请求ARQ：即上述的重传与确认机制，保证在不可靠的传输网络实现可靠的通信，简单但信道利用率低（2）连续ARQ协议(利用滑动窗口实现)基本原理：发送方可以连续发送分组，不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。优点：提高信道利用率，容易实现，即使确认丢失，也不必重传。缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。二、滑动窗口TCP的滑动窗口是以字节为单位的，并且可以动态变化的发送端的三种发送状态：已发送且收到确认的序号：发送窗口前面的序号（不再保留被删除）允许发送的序号：发送窗口里面的序号（已发送但未确认、可发送但未发送）未允许发送的序号：发送窗口后面的序号接收端的三种接受状态：已发送确认且并交付主机的数据允许接收的数据为允许接收的数据过程：发送端发送 发送窗口 中的数据，接收端按序接受数据并给出确认，如果数据没有按序到达（数据丢失），则接收端只能给出按序到达的数据中的最高序号给出确认，发送端要根据收到的确认号重传确认号后的数据（比如连续ARQ的例子）二、TCP的流量控制思想：让发送方的发送速率不要太快，让接收方来得及接受，因此发送方的发送窗口不能超过接受端的接受窗口的数值利用滑动窗口实现：滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。三、TCP 的拥塞控制主要是下面的四种机制：一、慢启动（慢开始）：发送方维持一个拥塞窗口（cwnd）的状态变量，拥塞窗口的大小取决于网络的阻塞程度，并且动态变化思路：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。为举例说明，这里使用报文段的个数作为拥塞窗口大小的单位（实际上拥塞窗口大小是以字节为单位的）过程：一开始发送方先设置 cwnd=1，发送第一个报文M1接收方收到后确认M1，发送方收到确认后，将cwnd从1增大为2发送方每收到一个对新报文的确认（重传不算在内）就使发送方的拥塞窗口加1，所以每经过一个传输轮次，拥塞窗口cwnd就加倍慢开始不是指 拥塞窗口cwnd 的增长速度慢（指数增长），而是指开始时cwnd=1一次传输轮次的时间=晚饭时间RTT=所有报文发送完毕并收到确认的时间为了防止 cwnd 增长过大引起网络拥塞，设置一个慢开始门限（ssthresh 状态变量）当 cnwd＜ssthresh，使用慢开始算法当 cnwd=ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法当 cnwd＞ssthresh，使用拥塞避免算法二、拥塞避免：思路：让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞控制窗口加1拥塞避免并非完全能够避免拥塞，而是cwnd按线性规律缓慢增加，比慢开始算法的倍数增长速率缓慢得多，使网络比较不容易出现拥塞无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为 1，执行慢开始算法。 如图所示：在TCP拥塞控制的文献中也成为“乘法减小”和”加法增加“，上述两种算法合起来就是AIMD算法三、快速重传：思路：快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量。四、快速恢复：当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半，为了避免网络发生拥塞。但是接下去并不执行慢开始算法。考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 的大小，然后执行拥塞避免算法。发送端有cwnd发送窗口，接收端也有rwnd接收窗口（通知窗口）发送端发送窗口的大小取决于网络拥塞程度，但接收端的缓存空间有限，所以接收端的接受窗口是根据自己的接受能力来设置的，并把这个窗口值写入TCP首部中的窗口字段，传送给发送方。因此，从接收方对发送方的流量控制的角度考虑，发送方的发送窗口一定不能超过对方给出的接收窗口值rwnd。即发送方窗口的上限值 = Min [ rwnd, cwnd ]当rwnd &lt; cwnd 时，是接收方的接收能力限制发送方窗口的最大值。当cwnd &lt; rwnd 时，则是网络的拥塞限制发送方窗口的最大值。也就是：rwnd和cwnd中较小的一个控制发送方发送数据的速率拥塞控制和流量控制的区别拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP的报文格式与连接]]></title>
    <url>%2F2019%2F09%2F09%2FTCP%E7%9A%84%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%E4%B8%8E%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[TCP是一个面向连接的、提供可靠传输的、全双工通信、面向字节流的传输层协议。本文先讲述TCP报文格式以及TCP连接的过程。TCP报文段首部格式源端口（2）： 数据发送方的端口号。目的端口（2）： 数据接受方的端口号。序号（4）：seq序号，记录本报文段所发送的第一个字节的序号。例如：一报文段字段值是301，携带数据共有100字节，因为在TCP连接中传送的字节流中的每一个字节都按顺序编号，所以本报文段的第一个字节的序号是301，最后一个字节的序号是400，那么下一个报文段应当从401开始确认号（4）：ack序号，即接收端希望收到的下一个数据报文中的第一个字节的序号。​ 只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。（上面例子里确认号=401）数据偏移（4位）：表示TCP报文段的数据起始处距离TCP报文段的起始处有多远（即TCP报文段的首部长度）数据偏移的单位是32bit，即4字节；因为4位二进制能够表是的最大十进制数是15，所以数据偏移的最大长度是15*4=60字节，除去固定部分的20字节，选项字段最大不能超过40字节保留（6位）紧急比特URG（1位）：当值为1时表示次报文段中有需要紧急处理。确认比特ACK（1位）：确认序号是否有效，为1时有效，为0时无效。TCP规定连接建立后传送报文段ACK=1推送比特PSH（1位）：接收方应该尽快将这个报文交给应用层。复位比特RST（1位）：重置连接，值为1时表示TCP连接存在严重的错误，需要重新进行连接。同步比特SYN（1位）：建立连接，在连接建立时同步序号，SYN=1时表示这是一个连接请求或连接接受报文当SYN=1且ACK=0时，表明这时一个连接请求报文段当SYN=1且ACK=1时，表明对方同意建立连接所以SYN=1时表示这是一个连接请求或连接接受报文终止比特FIN（1位）： 用于释放连接，值为1表示要发送的数据报已经发送完毕，需要释放传送连接。窗口字段（2）：接收端根据缓存空间的大小确定自己接受窗口的大小，限制发送放的窗口上限。检验和：用来检验首部和数据两部分的正确性。紧急指针字段：本报文紧急报文的最后一个字节的序号。需要注意的是：不要将确认序号ack与标志位中的ACK搞混了，确认方ack=发起方seq+1，两端配对。TCP的连接每一条TCP连接有两个端点，端点叫socket（套接字）socket是一个 五元组，包括：源IP、源端口、目的IP、目的端口、类型：TCP or UDP这个五元组，即标识了一条可用的连接。例如，本地IP是180.172.35.150，在浏览器中连接某一个Web服务器，例如百度，这条socket连接的五元组可能就是：[180.172.35.150:45678, tcp, 180.97.33.108:80]源IP为你的出口IP地址 180.172.35.150，源端口为随机端口 45678，目的IP为百度的某一个负载均衡服务器IP 180.97.33.108，端口为HTTP标准的80端口三次握手三次握手的过程：刚开始客户端处于 closed 的状态，服务端处于 listen 状态。然后1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号seq=X（seq利用ISN生成）。此时客户端处于 SYN_Send （同步已发送） 状态。2、第二次握手：服务器收到客户端的 SYN 报文后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号seq=Y，同时会把客户端的seq + 1 作为 Ack （确认序号）的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD（同步收到）的状态。3、第三次握手：客户端收到服务器 SYN 报文之后，会发送一个 ACK应答 报文，也是一样把服务器的seq + 1 作为 Ack 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。（此时客户端可以通过ACK报文段发送数据，但如果不发送数据则不消耗序号）4、服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方已建立连接三次握手的作用1、确认双方的接受、发送能力是否正常，是否可以传送数据。2、同步双方的初始化序列号，为后面的可靠传送做准备。3、协商窗口大小，同时接收方预留数据缓存区，为后面的可靠传送做准备。（ISN）是固定的吗三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。123ISN = M + F(localhost, localport, remotehost, remoteport)M是一个计时器，每隔4毫秒加1。F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。所以要保证hash算法不能被外部轻易推算得出。ISN是随机的，所以序列号容易就会超过2^31-1，就出现了“tcp序列号回绕”问题 参考博文四次挥手由于socket是全双工的工作模式，一个socket的关闭，是需要四次握手来完成的。四次挥手的过程：刚开始双方都处于 establised 状态，假如是客户端主动发起关闭请求（调用close()方法），则：1、第一次挥手：客户端发送一个 FIN 终止报文给服务器，报文中指定一个初始化序列号seq=U。此时客户端处于FIN_WAIT1状态。2、第二次挥手：服务端收到 FIN 之后，因为还有数据未发送完，所以服务器会先发送一个 ACK 应答报文，指定一个初始化序列号seq=V，且把客户端的序列号值seq + 1 作为确认序号的值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。客户端等待服务器关闭，则进入FIN_WAIT_2状态；此时，客户端 等待 服务器 发起关闭请求3、第三次挥手：服务器在完成所有数据发送后，主动发起关闭请求，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个初始化序列号seq=W。此时服务端处于 LAST_ACK 的状态。4、第四次挥手：客户端收到 FIN 之后，发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。等待2MSL（最长报文段寿命），主动关闭的一方，结束TIME-WAIT，进入CLOSED状态四次挥手的作用：确保数据能够完成传输，而不是发送FIN报文后对方立即关闭连接参考博文：关于3次握手与4次挥手TIME_WAIT的作用或2MSL的作用防止前一个连接上延迟的数据包或丢失重传的数据包，被后面复用的连接错误接收(异常:数据丢失或传输慢）SEQ=3的数据包丢失，重传第一次，没有得到ACK确认如果没有TIME_WAIT，或TIME_WAIT时间非常短，那么关闭的连接马上被重用，并连续发送SEQ=1,2 的数据包【180.172.35.150:45678, tcp, 180.97.33.108:80 的状态变为了CLOSED，源端口可被再次利用】【对180.97.33.108:80新建的连接，复用了之前的随机端口45678】此时，前面的连接上的SEQ=3的数据包再次重传，同时，seq的序号刚好也是3（这个很重要，不然，SEQ的序号对不上，就会RST掉），此时，前面一个连接上的数据被后面的一个连接错误的接收利用2MSL（最长报文段寿命）的等待时间，就可以**使本连接持续的时间内所产生的所有报文段都从网络中消失确保连接方能在时间范围内，关闭自己的连接（也是因为丢包导致的），即为了保证主动关闭方发送的最后一个ACK报文能够到达被动关闭方。总的来说就是为了解决网络的丢包和网络不稳定所带来的其他问题参考博文：你所不知道的TIME_WAIT]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM虚拟机]]></title>
    <url>%2F2019%2F08%2F31%2FJVM%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[讲述Java内存模型Java体系Java内存模型1. Run-Time Data Areas 运行时数据区JAVA虚拟机定义了各种用于程序执行时的运行时数据区：a) 一些数据区是与虚拟机的生命周期一致的：创建于虚拟机开始运行时，销毁于虚拟机退出时b) 一些数据区是与线程生命周期一致的：创建于线程创建，毁于线程推出在数据区中：线程私有：Program Counter Register、JVM Stacks、Native Method Stacks（无GC）线程共享：Heap、Method Area（有GC）1.1 Program Counter Register 程序计数器程序计数器是指CPU中的寄存器执行java方法时，程序计数器是有值的，存储的是当前执行的字节码指令的地址（保存下一条指令的所在存储单元的地址）CPU根据保存的指令地址找到指令，然后在执行。目的是防止多线程执行时出现干扰，单线程的话可以没有PC执行native本地方法时，程序计数器的值为空（Undefined）：因为native方法是java直接调用本地C/C++库进行实现，那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。程序计数器PC有足够的空间存储返回地址信息，占用的内存很小，所以PC是唯一一个JVM中没有OutOfMemoryError的区域。1.2 Native Method Stacks 本地方法栈作用场景：在程序调用或JVM调用本地方法（非java语言编写，不受JVM管理）接口(Native)时候启用，即本地方法栈将会在每个线程创建的是将被分配内存存储的是本地方法的数据​ 如上图的线程的start()方法创建时会调用一个native方法异常行为栈溢出：由于线程执行需要更大的栈而产生的异常，即线程过程执行需要存储大量内容而引起的内存溢出：由于内存不足无法分配给栈而导致的异常1.3 JVM Stacks 虚拟机栈每个Java虚拟机线程都有一个私有的Java虚拟机栈，JVM栈是运行的单位生命周期：因栈是线程私有的，所以与线程的生命周期一致：随线程创建，随线程结束销毁存储数据：Java虚拟机栈中存储栈帧：当前线程运行时所需要的局部变量、对象的引用、计算的结果、返回信息等栈的行为：压入(push)和弹出(pop)栈帧存取类型：压入和弹出栈帧采用FILO先进后出，因为是调用方法总是先完成。Java虚拟机栈的内存不需要是连续的JVM默认给每个栈分配的空间是1M，也可以自己在configurations中设置；所以如果分配给每个栈的内存越小，那么JVM所支撑的线程就越多1.3.1 Frames 栈帧存储数据：局部变量表：基本数据类型、变量对象的引用（指针）可操作数栈：方法执行过程中的结果运行环境区：动态连接、方法返回相关信息、抛出异常生命周期：每个方法都有一个栈帧，每次调用一个方法时就会创建一个栈帧，方法调用完后栈帧就被销毁，无论方法是否时正常结束或抛出异常。局部变量与操作数栈的大小在编译时就确定了当前栈：在线程运行时，仅有且只有一个正在运行的方法的栈帧；它对应的方法就是当前运行的方法，当前运行的类就是当前类。在局部变量和操作数栈上的操作是和当前栈帧相关的栈帧会在方法调用另外一个方法或方法结束后停止。当一个方法被调用且控制权转为这个新的方法时，那么一个新的栈帧就会被创建成为当前栈帧。在方法返回时，当前栈帧就会将返回结果传递给调用者的栈帧（如果有的话）这个栈帧就会被之前的那个栈帧取代成为当前栈帧。1.3.1.1 Local Variables 局部变量表存储局部变量、对象的引用一个单独的局部变量可以存储基本数据类型的值、引用，long和double型可以用两个局部变量来存储局部变量使用索引来表示的，第一个局部变量的索引是0。一个整数可以当做一个索引，只要整数在[0，局部变量表的长度] 区域内。一个long、double类型的值占据两个连续的局部变量虚拟机通过局部变量在方法调用过程中传递参数：在类方法调用时，任何参数都在从局部变量0开始的连续局部变量中传递。在实例方法调用中，局部变量0始终用于存储对调用实例方法的对象的引用（这在Java编程语言中）。 随后，任何参数都在从局部变量1开始的连续局部变量中传递。1.3.1.2 operand stack 操作数栈每个栈帧包含一个采用LIFO先进后出的操作数栈存储执行过程中的结果：Java虚拟机提供指令，将局部变量或常量的值或内容加载到操作数栈上（不是局部变量和常量加载到操作数栈中）Java虚拟机指令从操作数栈中获取操作数，对它们进行操作，并将结果推回操作数栈中。例如：iadd指令将两个int值相加，于是将操作数栈的前两个int值相加，将结果压入栈中，并且两个int值都从操作数堆栈中弹出删除。操作数栈具有相关联的深度：其中long或double类型的值占据两个单位深度，而其他类型的值占一个单位。方法调用时可操作数栈与局部变量的互动调用add()方法时创建add方法的栈帧iconst_1 ：把int类型的1压入可操作数栈中istore_1： 将可操作数栈中的int类型1存入局部变量表中的第一个位置：结果a＝1；同理，b=2iload_1：将局部变量的第1、2个位置的数（即a、b的值）加载到操作数栈中执行iadd加法：将1、2从栈中弹出相加，并将结果3压入栈中istore_3 ：将int类型的3压入局部变量表中iload_3：将局部变量的第3个位置的数（即c的值）加载到操作数栈中return ：返回1.3.1.3 Dynamic Linking 动态链接即多态：动态链接将抽象的引用转化为具体的引用1.3.1.4 Normal Method Invocation Completion 方法正常结束当被调用的方法执行到return返回指令时，必须返回适合的值类型（如果有的话）当调用方法正常结束时：当前帧用于恢复调用者的状态，包括其局部变量和操作数堆栈调用者的程序计数器适当增加以跳过调用方法指令：比如调用者执行add()方法时是第9行，那么调用方法结束后PC+1，就变为第10行，这样调用者就会执行第10行的操作）然后执行在调用方法的栈帧会将正常返回的值（如果有）压入该帧的操作数堆栈。1.3.1.5 Abrupt Method Invocation Completion 方法异常结束非正常结束的调用方法：抛出异常或错误如果当前方法没有捕获到异常，则会导致方法调用突然结束。 这种方法结束调用时永远不会向其调用者返回值讲完线程私有，接下来的就是线程共享的：1.4 Heap 堆堆是存储的单位，栈是运行的单位存储内容：记录所有实例对象和数组生命周期：堆随虚拟机开始时创建堆内存不连续垃圾收集器管理的主要区域：当方法结束后，虚拟机栈会立即消失，而堆内存存储的对象的引用不会立即消失，而是等到gc进行回收GC回收原则：当没有任何对象引用指向堆内存里面的对象时从内存回收的角度来看，由于现在的收集器基本都采用分代收集算法，所以堆又可以细分成：新生代和老年代，新生代里面有分为：Eden空间、From Survivor空间、To Survivor空间。默认情况下，新生代中Eden空间与Survivor空间的比例是8:1，可以使用参数-XX:SurvivorRatio对其进行配置。大多数情况下，新生对象在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，则触发一次Minor GC，将对象Copy到Survivor区，如果Survivor区没有足够的空间来容纳，则会通过分配担保机制提前转移到老年代去。何为分配担保机制？在发送Minor GC前，JVM会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果是，那么可以确保Minor GC是安全的，如果不是，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果小于，直接进行Full GC，如果大于，将尝试着进行一次Minor GC，Minor GC失败才会触发Full GC。注：不同版本的JDK，流程略有不同。Survivor区作为Eden区和老年代的缓冲区域，常规情况下，在Survivor区的对象经过若干次垃圾回收仍然存活的话，才会被转移到老年代。JVM通过这种方式，将大部分命短的对象放在一起，将少数命长的对象放在一起，分别采取不同的回收策略。1.5 Method Area（meta space）方法区存放数据：每个class的信息:类名字段信息每个字段名字、类型(如类的全路径名、类型或接口) 、修饰符（如public、abstract、final）、属性方法信息每个方法的名字、返回类型、参数类型(按顺序)、修饰符、属性运行时常量池：全局变量、所有常量、字段引用、方法引用、属性方法代码每个方法的字节码、操作数栈大小、局部变量大小、局部变量表、异常表和每个异常处理的开始位置、结 束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引类加载器引用(classLoader)方法区直接放在本地的物理内存（直接内存），其他的都放在JVM内存中如果内存不足会报内存不足错误1.5.1 Run-Time Constant Pool 运行时常量池方法区的一部分，存放在编译期间，就可以确定下来的值字面量：如final、String及其包装类的值1int a=1;//1就是字面量符号引用：由于不知道所引用类的实际地址，而以符号的形式表现出来的与直接引用不同，直接引用直接利用指针指向具体的实际地址创建时间：当Java虚拟机创建类或接口时，将构造类或接口的运行时常量池；除了编译产生能存入，运行期间也能将新的常量放入池中(String.intern())节省内存空间：常量池中如果有对应的字符串，那么则返回该对象的引用，从而不必再次创建一个新对象。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
</search>
