<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Keep study">
<meta property="og:type" content="website">
<meta property="og:title" content="qinnsang&#39;s blog">
<meta property="og:url" content="https://qinnsang.github.io/index.html">
<meta property="og:site_name" content="qinnsang&#39;s blog">
<meta property="og:description" content="Keep study">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="qinnsang&#39;s blog">
<meta name="twitter:description" content="Keep study">
  <link rel="canonical" href="https://qinnsang.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>qinnsang's blog</title>
  <meta name="generator" content="Hexo 3.9.0">
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">qinnsang's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">0</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">0</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">2</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://qinnsang.github.io/2019/08/31/马士兵-并发编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qinnsang">
      <meta itemprop="description" content="Keep study">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qinnsang's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/31/马士兵-并发编程/" class="post-title-link" itemprop="url">未命名</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-31 11:40:15" itemprop="dateCreated datePublished" datetime="2019-08-31T11:40:15+08:00">2019-08-31</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-06 22:22:13" itemprop="dateModified" datetime="2019-08-06T22:22:13+08:00">2019-08-06</time>
              </span>
            
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span></span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span></span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>==内存模型抽象结构</p>
<h2 id="1-Java内存模型"><a href="#1-Java内存模型" class="headerlink" title="1. Java内存模型"></a>1. Java内存模型</h2><p>Java内存模型是==内存共享==的并发模型，线程之间主要通过读-写共享变量来完成通信。</p>
<h2 id="2-共享变量"><a href="#2-共享变量" class="headerlink" title="2. 共享变量"></a>2. 共享变量</h2><ul>
<li>共享变量：==堆内存==中的变量所有线程均可访问到，是可以共享的：所有==实例域，静态域和数组元素==</li>
<li>非共享变量：局部变量，方法定义参数和异常处理器参数不会在线程间共享</li>
<li><strong>共享数据会出现线程安全的问题，而非共享数据不会出现线程安全的问题</strong></li>
</ul>
<h2 id="3-JMM抽象结构模型"><a href="#3-JMM抽象结构模型" class="headerlink" title="3. JMM抽象结构模型"></a>3. JMM抽象结构模型</h2><p>① 由于CPU的处理速度和主存的读写速度不是一个量级的，为了平衡这种巨大的差距，每个CPU都会有缓存。</p>
<p>② 因此，<strong>共享变量</strong>会先放在<strong>主存</strong>中</p>
<p>③ ==每个线程都有属于自己的工作内存==，并且会把位于==主存中的共享变量拷贝到自己的工作内存==，线程之后的读写操作均使用位于工作内存的变量副本，并在<strong>某个时刻</strong>将工作内存的==变量副本写回到主存==中去。</p>
<p>③ JMM就从抽象层次定义了这种方式，并且JMM决定了一个线程对共享变量的写入何时对其他线程是可见的。<br><img src="https://upload-images.jianshu.io/upload_images/2615789-8c0b960a27af28db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/792/format/webp" alt="img"></p>
<p>如图为JMM抽象示意图，线程A和线程B之间要完成通信的话，要经历如下两步：</p>
<ol>
<li>线程A从主内存中将共享变量读入线程A的工作内存后并进行操作，之后将数据重新写回到主内存中；</li>
<li>线程B从主存中读取最新的共享变量</li>
</ol>
<p>为了避免发生脏读，使用线程并发控制机制</p>
<h1 id="线程并发"><a href="#线程并发" class="headerlink" title="线程并发"></a>线程并发</h1><h2 id="Synchronized互斥锁"><a href="#Synchronized互斥锁" class="headerlink" title="Synchronized互斥锁"></a>Synchronized互斥锁</h2><p>锁信息记录在堆内存对象中的，不是在栈引用中</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2615789-08f16aeac7e0977d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/993/format/webp" alt="img"></p>
<h3 id="被锁对象"><a href="#被锁对象" class="headerlink" title="被锁对象"></a>被锁对象</h3><h4 id="1-代码块中的实例对象Object"><a href="#1-代码块中的实例对象Object" class="headerlink" title="1. 代码块中的实例对象Object"></a>1. 代码块中的实例对象Object</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 任何线程要执行下面的代码，都必须先拿到lock锁</span></span><br><span class="line">          					  <span class="comment">// 如果lock已经被锁定，其他线程再进入时，就会进行阻塞等待</span></span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当代码块执行完毕后，锁就会被释放，然后被其他线程获取</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-代码块中的类实例对象-this"><a href="#2-代码块中的类实例对象-this" class="headerlink" title="2. 代码块中的类实例对象 this"></a>2. 代码块中的类实例对象 this</h4><p>由于每次使用锁都要newObject，比较麻烦，可以使用this代替object锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">// 任何线程要执行下面的代码，必须先拿到this锁</span></span><br><span class="line">           					 <span class="comment">// synchronized 锁定的不是代码块，而是 this 类的实例对象</span></span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-代码块中的类对象"><a href="#3-代码块中的类对象" class="headerlink" title="3. 代码块中的类对象"></a>3. 代码块中的类对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (T.class) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronize不仅可以放在代码块中，还可以放在方法上</p>
<h4 id="4-实例方法上的类实例对象"><a href="#4-实例方法上的类实例对象" class="headerlink" title="4. 实例方法上的类实例对象"></a>4. 实例方法上的类实例对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123; <span class="comment">// 等同于 synchronized (this) &#123; </span></span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-静态方法上的类对象"><a href="#5-静态方法上的类对象" class="headerlink" title="5. 静态方法上的类对象"></a>5. 静态方法上的类对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123; <span class="comment">// 等同于 synchronized (c_004.T.class) &#123; </span></span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul>
<li>==原子性==：一个操作是不可中断的，要么全部执行成功要么全部执行失败</li>
<li>==可见性==：当一个线程修改了共享变量后，其他线程能够立即得知这个修改</li>
<li>==有序性==：表示锁在同一时刻只能由一个线程进行获取，当锁被占用后，其他线程只能等待。</li>
</ul>
<h3 id="同步方法的调用问题"><a href="#同步方法的调用问题" class="headerlink" title="同步方法的调用问题"></a>同步方法的调用问题</h3><h4 id="1-同步与非同步方法是否可以同时调用"><a href="#1-同步与非同步方法是否可以同时调用" class="headerlink" title="1. 同步与非同步方法是否可以同时调用"></a>1. 同步与非同步方法是否可以同时调用</h4><p>可以，虽然锁的是整个对象，但是内部的方法不是同步的话也可以访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" m1 start"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" m1 end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" m2 start"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" m2 end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">new</span> Thread(t::m1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t::m2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//Thread-0 m1 start</span></span><br><span class="line"><span class="comment">////Thread-1 m2 start</span></span><br><span class="line"><span class="comment">////Thread-1 m2 end </span></span><br><span class="line"><span class="comment">////Thread-0 m1 end</span></span><br></pre></td></tr></table></figure>

<h4 id="2-一个同步方法是否可以调用另一个同步方法"><a href="#2-一个同步方法是否可以调用另一个同步方法" class="headerlink" title="2. 一个同步方法是否可以调用另一个同步方法"></a>2. 一个同步方法是否可以调用另一个同步方法</h4><p>synchronized 是可重入锁：即一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请时仍然会得到该对象的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m1 start "</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">" m2"</span>); <span class="comment">// 这句话会打印，调用m2时，不会发生死锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-子类是否可以调用父类的同步方法"><a href="#3-子类是否可以调用父类的同步方法" class="headerlink" title="3. 子类是否可以调用父类的同步方法"></a>3. 子类是否可以调用父类的同步方法</h4><p>可以，synchronized 是可重入锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m start "</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"m end "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TT tt = <span class="keyword">new</span> TT();<span class="comment">//new一个子类对象，就先new一个父类对象，锁对象是子类对象</span></span><br><span class="line">        tt.m();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TT</span> <span class="keyword">extends</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" child m start "</span>);</span><br><span class="line">        <span class="keyword">super</span>.m();</span><br><span class="line">        System.out.println(<span class="string">" child m end "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//child m start</span></span><br><span class="line"><span class="comment">////m start</span></span><br><span class="line"><span class="comment">////m end</span></span><br><span class="line"><span class="comment">////child m end</span></span><br></pre></td></tr></table></figure>

<h4 id="4-被锁对象的属性或引用的改变"><a href="#4-被锁对象的属性或引用的改变" class="headerlink" title="4. 被锁对象的属性或引用的改变"></a>4. 被锁对象的属性或引用的改变</h4><ol>
<li>如果锁定对象的属性的值发生变化，不影响锁的使用</li>
<li>如果锁定对象的引用发生变化，同步机制失效，多个线程可以同时访问变量<ol>
<li>锁的是堆内存中的对象，而不是栈内存中的对象的引用，所以new一个新对象后，锁引用就变了</li>
<li>所以锁对象通常要设置为 final类型，保证引用不可以变</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> String nochange;</span><br><span class="line">    <span class="keyword">private</span> String change=<span class="string">""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为加锁的是整个while循环，所以线程1会一直运行下去，锁不会被释放，所以线程2不能取得锁</span></span><br><span class="line">        <span class="comment">//当改变锁引用后，这是线程2可以申请到锁，所以可以打印</span></span><br><span class="line">        <span class="comment">//并且两个线程都有对应的两把锁，因为有两个new出来的队内存对象？</span></span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">new</span> Thread(t::m, <span class="string">"线程1"</span>).start();</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(t::m, <span class="string">"线程2"</span>);</span><br><span class="line">        t.setNochange(<span class="string">"对象的引用不改变"</span>)<span class="comment">//用set不会改变</span></span><br><span class="line">        t.change=<span class="string">"引用改变"</span>;<span class="comment">//指向一个新的对象的引用</span></span><br><span class="line">        t.o = <span class="keyword">new</span> Object(); <span class="comment">// 改变锁引用, 线程2也有机会运行，否则一直都是线程1 运行，因为锁一致被线程1占用</span></span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>注意：==不要以字符串常量作为锁定对象==</li>
</ol>
<p>在下面的例子中， m1和m2其实是锁定的同一对象，这种情况下，还会可能与其他类库发生死锁，比如某类库中也锁定了字符串 “Hello”，但是无法确认源码的具体位置，所以两个 “Hello” 将会造成死锁，因为你的程序和你用的类库无意间使用了同意把锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String s1 = <span class="string">"Hello"</span>;</span><br><span class="line">    String s2 = <span class="string">"Hello"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (s1) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (s2) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常时释放锁"><a href="#异常时释放锁" class="headerlink" title="异常时释放锁"></a>异常时释放锁</h3><p>synchronized锁在发生异常后会==主动释放锁==，并且发生异常时要小心处理同步业务员逻辑中的异常，不然可能发生数据不一致的情况。异常处理用==try-catch捕获处理==</p>
<p>eg：在一个web app处理过程中，多个servlet线程共同访问同一资源，这时如果异常处理不合适，第一个线程抛出异常，其他线程就会进入同步代码区，有可能访问到异常产生的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" start"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count="</span> + count);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">5</span>) &#123;  <span class="comment">// 当count == 5 时，synchronized代码块会抛出异常</span></span><br><span class="line">                               <span class="comment">// 要想正常运行，用try-catch捕获处理异常</span></span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.m();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">"t1"</span>).start(); <span class="comment">// 执行到第5秒时，抛出 ArithmeticException </span></span><br><span class="line">        <span class="comment">// 如果抛出异常后，t2 会继续执行，就代表t2拿到了锁，即t1在抛出异常后释放了锁</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//	  t1 start</span></span><br><span class="line"><span class="comment">//    t1 count=1</span></span><br><span class="line"><span class="comment">//    t1 count=2</span></span><br><span class="line"><span class="comment">//    t1 count=3</span></span><br><span class="line"><span class="comment">//    t1 count=4</span></span><br><span class="line"><span class="comment">//    t1 count=5</span></span><br><span class="line"><span class="comment">//    t2 start</span></span><br><span class="line"><span class="comment">//    t2 count=6</span></span><br><span class="line"><span class="comment">//    Exception in thread "t1" java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">//        at mashibing.c_011.T.m(T.java:30)</span></span><br><span class="line"><span class="comment">//        at mashibing.c_011.T$1.run(T.java:40)</span></span><br><span class="line"><span class="comment">//        at java.lang.Thread.run(Thread.java:748)</span></span><br><span class="line"><span class="comment">//    t2 count=7</span></span><br><span class="line"><span class="comment">//    t2 count=8</span></span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>同步代码块中的语句越少越好, 采用==细粒度==的锁，可以使线程争用时间变短，从而提高效率</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 业务逻辑中，只有下面这句代码需要 sync， 这时不应该给整个方法上锁</span></span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//改进： </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 业务逻辑中，只有下面这句需要 sync，这时不应该给整个方法上锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><p>前提：由于线程在工作时会将共享变量复制到自己的工作空间，从而使得在CPU忙碌时，线程对共享变量副本的修改没有及时写会到主内存中，导致共享变量的数据不一致。</p>
<p>作用：确保将变量的更新操作通知到其他线程，保证共享变量数据一致</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*volatile*/</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;   <span class="comment">// 对比有无volatile的情况下，整个程序运行结果的区别</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" m start "</span>);</span><br><span class="line">        <span class="keyword">while</span> (running) &#123; <span class="comment">// 直到主线程将running设置为false，T线程才会退出</span></span><br><span class="line">            <span class="comment">// 在while中加入一些语句，可见性问题可能就会消失</span></span><br><span class="line">            <span class="comment">//因为加入语句后，CPU可能就会出现空闲，然后就会将共享变量副本同步到到主内存</span></span><br><span class="line">            <span class="comment">//所以，可见性问题可能会消失</span></span><br><span class="line">            <span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">                TimeUnit.MILLISECONDS.sleep(10);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">" m end "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">new</span> Thread(t::m, <span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t.running = <span class="keyword">true</span>;<span class="comment">//主线程设置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>无volatile：上面的代码中，running 是位于堆内存中的t对象的，当线程t1开始运行的时候，CPU会把running值从内存中读到t1线程的工作区，在运行过程中直接使用这个copy；由于CPU繁忙，并不会每次都会将共享变量副本写回到主内存中，这样，当主线程修改running的值之后，t1线程感知不到，所以不会停止运行</p>
</li>
<li><p>使用volatile，当线程修改running值后，会通知所有线程值改变了，要重新读，所以会强制所有线程都去堆内存中读取running的值，这样t线程就会停止运行</p>
</li>
</ul>
<h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><ul>
<li>有序性、可见性</li>
</ul>
<h4 id="对比synchronized"><a href="#对比synchronized" class="headerlink" title="对比synchronized"></a>对比synchronized</h4><ul>
<li>volatile只能保证可见性，不能保证原子性，所以volatile不能替代synchronized</li>
<li>synchronized既保证可见性，也保证原子性</li>
<li>volatile比synchronized效率高</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*AtomicInteger count = new AtomicInteger(0);*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">/*count.incrementAndGet();*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个10个线程的list，执行任务皆是 m方法</span></span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(t::m, <span class="string">"t-"</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动这10个线程</span></span><br><span class="line">        threads.forEach(Thread::start);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// join 到主线程，防止主线程先行结束</span></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 10个线程，每个线程执行10000次，结果应为 100000</span></span><br><span class="line">        System.out.println(t.count);  <span class="comment">// 所得结果并不为 100000，说明volatile 不保证原子性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解决方案：</span></span><br><span class="line"><span class="comment">1. 在方法上加上synchronized即可，synchronized既保证可见性，又保证原子性</span></span><br><span class="line"><span class="comment">2. 使用AtomicInteger代替int（AtomicXXX 代表此类中的所有方法都是原子操作，并且可以保证可见性）</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock 可以完成 synchronized 的任何功能，ReentrantLock比 synchronized 更灵活，主要体现在如下几个方面：</p>
<ol>
<li>ReentrantLock是手动锁，异常后不会释放锁，synchronized异常时jvm会自动释放锁</li>
<li>tryLock 尝试锁定，非阻塞锁，可以设置等待时间</li>
<li>lockInterruptibly 可以中断等待</li>
<li>可以设置公平锁</li>
</ol>
<h3 id="手动锁"><a href="#手动锁" class="headerlink" title="手动锁"></a>手动锁</h3><ul>
<li><p>ReentrantLock是==手动锁，异常后不会释放锁==，必须要手动释放锁，一般在<strong>finally中释放锁</strong></p>
</li>
<li><p>synchronized异常时jvm会自动释放锁</p>
</li>
<li><p>ReentrantLock是手动锁，异常后不会释放锁，必须要手动释放锁，一般在finally中释放锁</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Lock*/</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 相当于 synchronized</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 使用完毕后，必须手动释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"m2..."</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock2 r1 = <span class="keyword">new</span> ReentrantLock2();</span><br><span class="line">        <span class="keyword">new</span> Thread(r1::m1, <span class="string">"t1"</span>).start(); <span class="comment">// m1 已经执行，被t1占有锁this</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(r1::m2, <span class="string">"t2"</span>).start(); <span class="comment">// 锁已经被其他线程占用，m1执行完毕前，不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可”尝试锁定“"><a href="#可”尝试锁定“" class="headerlink" title="可”尝试锁定“"></a>可”尝试锁定“</h3><p>ReentrantLock 可使用==tryLock尝试锁定==， 这样无法锁定、或者在指定时间内无法锁定，线程可以决定是否继续等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock(); </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尝试获取锁，返回true拿到了</span></span><br><span class="line">        <span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">            <span class="comment">// lock.tryLock(5, TimeUnit.SECONDS) // 等5s内还没拿到就返回false</span></span><br><span class="line">            System.out.println(<span class="string">"m2..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">" m2 没拿到锁"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();<span class="comment">//加个是否拥有锁的判断，没有锁释放锁会发生异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock3 r1 = <span class="keyword">new</span> ReentrantLock3();</span><br><span class="line">        <span class="keyword">new</span> Thread(r1::m1, <span class="string">"t1"</span>).start(); <span class="comment">// m1 已经执行，被t1占有锁this</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(r1::m2, <span class="string">"t2"</span>).start(); <span class="comment">// 锁已经被其他线程占用，m1执行完毕后，不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可打断等待"><a href="#可打断等待" class="headerlink" title="可打断等待"></a>可打断等待</h3><p>在一个线程等待锁的过程中，==线程可以被interrupt方法打断等待==，ReentrantLock 可以调用 ==lockInterruptibly==方法判断是否被打断，对线程interrupt方法做出响应。</p>
<p><strong>lockInterruptibly方法作用：</strong><br>1）如果当前线程未被中断且锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。  </p>
<p>2）如果锁被另一个线程保持，则出于线程调度目的，禁用当前线程，并且在发生以下两种情况之一以<br>前，该线程将一直处于休眠状态：<br>     1）锁由当前线程获得；或者 </p>
<pre><code>2）其他某个线程中断当前线程。 </code></pre><p>3）如果当前线程获得该锁，则将锁保持计数设置为 1，并且该方法立即返回。<br>   如果当前线程：<br>       1）在进入此方法时已经设置了该线程的中断状态；或者 </p>
<pre><code>2）在等待获取锁的同时被中断。 </code></pre><p>   则抛出 InterruptedException，并且清除当前线程的已中断状态。 </p>
<p>6）因为此方法是一个显式中断点，所以要优先考虑响应中断，而不是响应锁的普通获取或重入获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock4</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"t1 start"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);  <span class="comment">// 线程一直占用锁</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();<span class="comment">//不可响应中断</span></span><br><span class="line">                lock.lockInterruptibly(); <span class="comment">// t2 尝试获取锁，可响应中断</span></span><br><span class="line">                System.out.println(<span class="string">"t2 start"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"t2 等待中被打断"</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//要进行判断是否拥有锁</span></span><br><span class="line">                lock.unlock(); <span class="comment">// 没有锁定进行unlock就会抛出 IllegalMonitorStateException </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//因为线程2一直在等待，如果不想让线程2等待，想中断它，</span></span><br><span class="line">        <span class="comment">// 那么让主线程打断2的等待，结束掉线程2</span></span><br><span class="line">        t2.interrupt();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可指定公平锁"><a href="#可指定公平锁" class="headerlink" title="可指定公平锁"></a>可指定公平锁</h3><ul>
<li>公平锁：等待时间最长的线程优先获得锁，效率较低</li>
<li>不公平锁：无论先后，线程调度器将会随机给某个线程锁，不用计算线程时序，效率较高</li>
</ul>
<p>ReentrantLock 可以指定为公平锁，效率比较低；</p>
<p>==synchronized 是不公平锁（竞争锁）==，效率比较高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock5</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//fair为false时，为不公平锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);<span class="comment">// 指定锁为公平锁</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"获取锁"</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock(); <span class="comment">// 公平锁 t1 unlock 后，等待时间长的一定是 t2 所以下次一定是 t2 执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock5 t1 = <span class="keyword">new</span> ReentrantLock5();</span><br><span class="line">        ReentrantLock5 t2 = <span class="keyword">new</span> ReentrantLock5();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ThreadLocal-线程局部变量"><a href="#ThreadLocal-线程局部变量" class="headerlink" title="ThreadLocal 线程局部变量"></a>ThreadLocal 线程局部变量</h2><p>ThreadLocal：适合用在需要线程内部自己维护，而不需要其他线程共同维护的共享变量的场景。当线程终止后，这些值会作为垃圾回收。</p>
<ul>
<li>ThreadLocal：使用空间换时间，将变量读到线程中  效率更高</li>
<li>线程同步：使用时间换空间，多个线程同时访问变量</li>
<li>ThreadLocal可能会导致内存泄漏</li>
</ul>
<p>ThreadLocal用set放入局部变量，用get取，用remove删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;Person&gt; p = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(p.get()); <span class="comment">// 2. 虽然threadLocal时共享变量，但是取不到其他线程放入的值，所以此处为null</span></span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            p.set(<span class="keyword">new</span> Person()); <span class="comment">// 1. 往线程局部变量set放入一个person</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">"zhangsan"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Singleton-单例模式"><a href="#Singleton-单例模式" class="headerlink" title="Singleton 单例模式"></a>Singleton 单例模式</h2><p>单例模式：<strong>系统中对于某类的只能有一个对象</strong>，如servlet就是单例多线程模式</p>
<p>单例模式的线程安全可以参考这篇博文：<a href="https://www.cnblogs.com/xudong-bupt/p/3433643.html" target="_blank" rel="noopener">设计模式之单例模式(线程安全)</a>，除了博文里介绍的实现三种方法外，还有第四种方法：采用==静态内部类==这种方式，==既不用加锁，也能实现懒加载==（只有当用到类的时候才开始加载）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton s = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><p>解决并发情况下的容器线程安全问题的，给多线程环境准备一个线程安全的容器对象。</p>
<h2 id="Map-Set"><a href="#Map-Set" class="headerlink" title="Map/Set"></a>Map/Set</h2><h3 id="无并发"><a href="#无并发" class="headerlink" title="无并发"></a>无并发</h3><ul>
<li><p>HashMap：基于哈希算法的==无序==key-value集合</p>
</li>
<li><p>LinkedHashMap：按照插入顺序或访问顺序进行排序的==有序==HashMap</p>
</li>
<li><p>TreeMap：基于==红黑树==的key-value集合，所以是==排序==好的map  </p>
</li>
</ul>
<p><u><strong>有序的插入时效率低 ，但读取效率高</strong></u></p>
<h3 id="加锁低并发"><a href="#加锁低并发" class="headerlink" title="加锁低并发"></a>加锁低并发</h3><ul>
<li>HashTable：每次加锁，都锁一个map对象，所以每次只有一个线程访问这个map对象       </li>
<li>Collections.synchronizedMap() ：将没有锁的map对象的变为加了锁的map</li>
</ul>
<h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><ul>
<li><p>ConcurrentHashMap - 并发高</p>
<p>加的是分段锁，将map容器分为16段，每段都有一个锁 segment，所以每次可以有多个线程同时访问者map容器中的一段数据，增加了并发性; <em>1.8以后 使用 Node + synchronized+CAS</em></p>
</li>
<li><p>ConcurrentSkipListMap </p>
<p>要求==高并发且排序==的情况时使用，插入效率较低，但是读取很快</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * skipMap: https://blog.csdn.net/sunxianghuang/article/details/52221913</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_ConcurrentMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); </span></span><br><span class="line">        <span class="comment">//Map&lt;String, String&gt; map = new Hashtable&lt;&gt;(); </span></span><br><span class="line">        <span class="comment">//Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); </span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;();  </span><br><span class="line">    </span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        Thread[] ths = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// 启动了一个门闩，每有一个线程退出，门闩就减1，直到所有线程结束，门闩打开，主线程结束</span></span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(ths.length); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 创建100个线程，每个线程添加10000个元素到map，并启动这些线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ths.length; i++) &#123;</span><br><span class="line">            ths[i] = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    map.put(<span class="string">"a"</span> + r.nextInt(<span class="number">10000</span>), <span class="string">"a"</span> + r.nextInt(<span class="number">100000</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;, <span class="string">"t"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.asList(ths).forEach(Thread::start);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();<span class="comment">//利用门闩让主线程等</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><strong>队列存取的几个方法：</strong></p>
<p>add与remove对应：队列满则抛出异常</p>
<p>offer与poll对应：不阻塞，队列满则返回false</p>
<p>put与take对应：阻塞，队满则等待</p>
<h3 id="无并发-1"><a href="#无并发-1" class="headerlink" title="无并发"></a>无并发</h3><p>ArrayList（无序）、LinkedList（有序）    </p>
<h3 id="低并发"><a href="#低并发" class="headerlink" title="低并发"></a>低并发</h3><ol>
<li>Collections.synchronizedList()：将普通集合List变为同步集合的工具方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T03_SynchronizedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 返回的实例，每个方法都加了一个互斥锁</span></span><br><span class="line">        List&lt;String&gt; syncList = Collections.synchronizedList(list);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>Vector   </p>
</li>
<li><p><strong>写时复制List：CopyOnWriteList</strong>  </p>
<p>原理：当发生写操作(添加、删除、修改)时，容器就会复制原有容器一份然后对新操作进行写操作，然后再将引用转向新的容器</p>
<p>好处：保证读操作不需要锁也能正常访问，是一种读写分离的实现方式</p>
<p>缺点：写的效率极低，特定场景下才会使用到，如事件监听器</p>
<p>==适用于写少读多==</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_CopyOnWriteList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list =</span><br><span class="line">                <span class="comment">//new ArrayList&lt;&gt;();//并发会出问题</span></span><br><span class="line">                <span class="comment">//new Vector&lt;&gt;(); //并发没有问题，但是效率低</span></span><br><span class="line">                <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();  <span class="comment">// 写速极慢，读取快</span></span><br><span class="line"></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        Thread[] ths = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ths.length; i++) &#123;</span><br><span class="line">            Runnable task = () -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    list.add(<span class="string">"a"</span> + r.nextInt(<span class="number">100</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            ths[i] = <span class="keyword">new</span> Thread(task);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        runAndComputeTime(ths);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAndComputeTime</span><span class="params">(Thread[] ths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Arrays.asList(ths).forEach(Thread::start);</span><br><span class="line">        Arrays.asList(ths).forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高并发-1"><a href="#高并发-1" class="headerlink" title="高并发"></a>高并发</h3><h4 id="非阻塞同步队列"><a href="#非阻塞同步队列" class="headerlink" title="非阻塞同步队列"></a>非阻塞同步队列</h4><h5 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h5><p>基于链接节点的==无界==线程安全队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_ConcurrentQueue</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            queue.offer(<span class="string">"a"</span> + i); </span><br><span class="line">            <span class="comment">// 有返回值，返回false代表没有加入成功，true 代表成功，并且此方法不会阻塞</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        System.out.println(queue.size());</span><br><span class="line"></span><br><span class="line">        System.out.println(queue.poll()); <span class="comment">// 取出队头</span></span><br><span class="line">        System.out.println(queue.size());</span><br><span class="line"></span><br><span class="line">        System.out.println(queue.peek()); <span class="comment">// 取出队头，但是不删除队头</span></span><br><span class="line">        System.out.println(queue.size());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 双端队列 Deque 发音： dai ke</span></span><br><span class="line">        <span class="comment">//Deque&lt;String&gt; deque = new ConcurrentLinkedDeque&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//deque.addFirst();</span></span><br><span class="line">        <span class="comment">//deque.addLast();</span></span><br><span class="line">        <span class="comment">//deque.pollFirst();</span></span><br><span class="line">        <span class="comment">//deque.pollLast();</span></span><br><span class="line">        <span class="comment">//deque.peekFirst();</span></span><br><span class="line">        <span class="comment">//deque.peekLast();</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="阻塞同步队列BlockQueue"><a href="#阻塞同步队列BlockQueue" class="headerlink" title="阻塞同步队列BlockQueue"></a>阻塞同步队列BlockQueue</h4><h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h5><p>阻塞==无界==同步队列，直到内存满了才会停止生产：put（生产，添加）和take（消费，拿出）对应</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成生产者消费者模式</span></span><br><span class="line"><span class="comment"> * 使用场景较多。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T05_LinkedBlockingQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">// 启动生产者线程生产</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(<span class="string">"aaa"</span> + j); <span class="comment">// put 方法，给容器添加元素，如果容器满了，则会阻塞等待</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"p"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启用消费者线程消费</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + queue.take()); <span class="comment">// 从队列中拿数据，如果空了，则会阻塞等待</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"c"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><p>阻塞==有界==同步队列：offer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T06_ArrayBlockingQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);<span class="comment">//容量为10个</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            queue.put(<span class="string">"a"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//queue.put("a11"); // 满了继续装会阻塞等待消费者消费</span></span><br><span class="line">        <span class="comment">//queue.add("a11"); // 满了继续装会抛出异常</span></span><br><span class="line">        <span class="comment">//System.out.println(queue.offer("a11")); // 满了继续装会返回false，不会将all加进去</span></span><br><span class="line">        System.out.println(queue.offer(<span class="string">"a11"</span>, <span class="number">1</span>, TimeUnit.SECONDS)); <span class="comment">// 会等待1s,返回false, 如果1s内有空闲,则添加成功后返回true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>LinkedBlockingQueue与ArrayBlockingQueue的区别</strong></p>
<ol>
<li><p>LinkedBlockingQueue是基于链表实现，ArrayBlockingQueue基于数组实现（FIFO）</p>
</li>
<li><p>LinkedBlockingQueue因为是链表，所以是无界的；而ArrayBlockingQueue创建时就指定了容量（LinkedBlockingQueue创建时，默认会直接创建一个Integer.MAX_VALUE的数组，当插入少，读取多时，就会造成很大的空间浪费。而LinkedBlockingQueue实际上实在等需要的时候才会创建一个Node节点。）</p>
</li>
<li><p>LinkedBlockingQueue内部读写各有一个锁，ArrayBlockingQueue读写共享一个锁</p>
</li>
<li><p>大多数场景适合使用LinkedBlockingQueue。在JDK源码当中有说明，LinkedBlockingQueue比ArrayBlockingQueue有更高的吞吐量，但是性能表现更难预测（也就是说相比ArrayBlockingQueue性能表现不稳定，但是也很稳定了）。</p>
<p>为什么会有吞吐量的区别，个人以为可能是ArrayBlockingQueue两个锁的缘故，在大量并发的情况下，插入和读取都很多时，就会造成一点的时间浪费。</p>
</li>
</ol>
<h5 id="TransferQueue"><a href="#TransferQueue" class="headerlink" title="TransferQueue"></a>TransferQueue</h5><p>原理：拥有transfer方法，传输，当transfer一个元素时，如果有take方法阻塞等待获取元素，则不向队列中保存，直接给等待的take方法</p>
<ul>
<li>情景：如果将元素放入队列，再拿给消费者线程，太慢了，如果需要的效率更高，可以使用TransferQueue来解决更高的并发</li>
<li>消费者线程先启动等待商品，生产者生产东西后直接交给消费者消费，不放进容器中，如果没有消费者等待消费，则会发生阻塞</li>
<li>put add 都不会阻塞，会直接添加到容器中，只有transfer才有此种等待消费者直接获取的功能，所以==transfer是有容量的==</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T08_TransferQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        TransferQueue mq = <span class="keyword">new</span> LinkedTransferQueue();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先让消费者线程等待</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(mq.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再让生产者线程生产</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mq.transfer(<span class="string">"aaa"</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果后让消费者启动则会报错</span></span><br><span class="line">        <span class="comment">/*new Thread(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(mq.take());</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;).start();*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h5><p>一种特殊的TransferQueue，==容量为0==</p>
<p>区别：TransferQueue是有容量的，可以通过add/put等方法向队列中加入元素；但是SynchronousQueue是没有的，所以生产的东西只能<strong>直接交给消费者消费，不能放在容器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T09_SynchronousQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        BlockingQueue queue = <span class="keyword">new</span> SynchronousQueue();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(queue.take()); <span class="comment">// 取不到就阻塞</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//queue.add("aaa"); // IllegalStateException: Queue full  抛出异常，因为没有容量</span></span><br><span class="line">        queue.put(<span class="string">"aaa"</span>);  <span class="comment">// 会阻塞等待消费者线程获取,内部是transfer</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(queue.size()); <span class="comment">// 长度为0 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h4><h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h5><p>出队有个时间限制, 每个元素有一个等待时间, 可以<strong>按照等待时间排序元素</strong>，DelayQueue元素必须为 ==Delayed类型==的,即<strong>必须设置元素的等待时间</strong></p>
<p>用途：<strong>定时执行任务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T07_DelayQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> runningTime;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">long</span> runTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.runningTime = runTime;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这是每个元素的等待时间, 越是后加入的元素,时间等待的越长</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> unit.convert(runningTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这是排序规律, 执行等待时间最短的排在前面</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) (o.getDelay(TimeUnit.MILLISECONDS) - <span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> runningTime + <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        MyTask myTask1 = <span class="keyword">new</span> MyTask(timestamp + <span class="number">1000</span>); <span class="comment">// 1s后执行</span></span><br><span class="line">        MyTask myTask2 = <span class="keyword">new</span> MyTask(timestamp + <span class="number">2000</span>);</span><br><span class="line">        MyTask myTask3 = <span class="keyword">new</span> MyTask(timestamp + <span class="number">1500</span>);</span><br><span class="line">        MyTask myTask4 = <span class="keyword">new</span> MyTask(timestamp + <span class="number">2500</span>);</span><br><span class="line">        MyTask myTask5 = <span class="keyword">new</span> MyTask(timestamp + <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        DelayQueue&lt;MyTask&gt; tasks = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line">        tasks.put(myTask1);</span><br><span class="line">        tasks.put(myTask2);</span><br><span class="line">        tasks.put(myTask3);</span><br><span class="line">        tasks.put(myTask4);</span><br><span class="line">        tasks.put(myTask5);</span><br><span class="line"></span><br><span class="line">        System.out.println(tasks);  <span class="comment">// 确实按照我们排的顺序执行的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.size(); i++) &#123;</span><br><span class="line">            System.out.println(tasks.take());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>作用：提高并行计算效率</p>
<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><ul>
<li>Executor只有一个execute接口，==用于执行任务==，可以<strong>传入一个Runnable接口</strong></li>
<li><strong>runnable接口</strong>用于==定义一项任务==, 将任务传递给Executor后, 由 Executor.execute() 方法定义如何执行任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_MyExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> T01_MyExecutor().execute(()-&gt; System.out.println(<span class="string">"hello executor"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        command.run();<span class="comment">//方法调用</span></span><br><span class="line">        <span class="comment">// new Thread(command).star(); //创建一个线程执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><p>ExecutorService是Executor的服务, service 一般都是后台线程, 启动后一直在后台运行,等待任务抛入，然后将任务扔到容器中执行.</p>
<h4 id="字段含义"><a href="#字段含义" class="headerlink" title="字段含义"></a>字段含义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">System.out.println(service); </span><br><span class="line"><span class="comment">//[Running, pool size = 5, active threads = 5, queued tasks = 1, completed tasks = 0]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>pool size =  5  线程池的容量</li>
<li>active thread = 5 激活的线程队列长度</li>
<li>queued tasks = 1 等待处理任务长度</li>
<li>completed task = 0 完成执行的任务数量     </li>
</ul>
<p><strong>与Executor的区别：</strong></p>
<ol>
<li>没有本质区别,只不过execute只能执行Runnable任务，ExecutorService还可执行Callable任</li>
<li>ExecutorService除了execute外还有submit可以扔任务</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_MyExecutorService</span>  </span>&#123;</span><br><span class="line">    ExecutorService executorService = <span class="keyword">null</span>;</span><br><span class="line">    Callable callable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h4><p>与类似Runnable，又有所区别：</p>
<ol>
<li>执行Runnable任务时,实际调用的是run方法；执行Callable任务时,实际调用的是 call方法 </li>
<li>callable 有返回值，Runnable没有返回值；如果线程运行结束后需要返回值,则需要callable </li>
<li>callable可以抛出异常,而Runnable不能抛出异常,必须自己处理</li>
</ol>
<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>未来的执行结果，在ExecutorService中，submit方法返回的是一个Future类型</p>
<ul>
<li>Future submit(Runnable): 提交Runnable任务以执行并返回表示该任务的Future</li>
<li>Future submit(Callable): 提交一个有返回值的callable任务,并将返回值作为future对象包装返回</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T06_Future</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未来的一个callable任务(因为有返回值)</span></span><br><span class="line">        <span class="comment">//因为FutureTask指定一个Integer泛型类，所以返回的100</span></span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//创建一个新的线程执行任务</span></span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(task.get()); <span class="comment">// 阻塞等待任务执行完成, 获取到返回值</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//********************************</span></span><br><span class="line">        <span class="comment">// 使用ExecutorService的submit替代FutureTask</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        Future&lt;Integer&gt; result = service.submit(() -&gt; &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(result.isDone()); <span class="comment">// false 执行未完毕</span></span><br><span class="line">        System.out.println(result.get()); <span class="comment">// 1 </span></span><br><span class="line">        System.out.println(result.isDone()); <span class="comment">// true  执行已完毕</span></span><br><span class="line">        System.out.println(result.get()); <span class="comment">// 一直等待</span></span><br><span class="line">        System.out.println(service.shutdownNow()); <span class="comment">// 立即等待</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>是一个用于操作上面对象的工具类和工厂类</p>
<h3 id="ThreadPool-线程池"><a href="#ThreadPool-线程池" class="headerlink" title="ThreadPool 线程池"></a>ThreadPool 线程池</h3><ul>
<li>线程启动和关闭要消耗资源，所以线程池省资源，不用每次都创建一个新的线程执行一个任务,而是线程池中有线程可以执行任务，有任务来线程就去执行，即用老线程去处理任务；线程池相当于工厂的工人，等待任务</li>
<li>每个线程都有自己的任务队列，等待去执行</li>
</ul>
<ul>
<li><p>线程池中维护了两个任务队列：未执行的任务队列、已执行的任务队列</p>
</li>
<li><p>线程池的几个状态：Running、Shutting down、Terminated</p>
</li>
</ul>
<p>ExecutorService的几个方法可以用来判断线程池状态：</p>
<ol>
<li>shutdown()：未执行完毕就不会停止运行,只会进入正在停止中的状态，running状态返回false</li>
<li>service.isTerminated()：判断所有任务是否执行完毕，除了terminated外的状态都返回false</li>
<li>isShutdown()：判断是否在停止中，shutting down状态返回true   </li>
</ol>
<p>==主要的线程池： FixedThreadPool、CachedThreadPool、SingleThreadExecutor、ScheduledThreadPool、WorkStealingPool、ForkJoinPool==</p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>线程池的实现原理，除了ForkJoinPool与WorkStealingPool线程池，其他线程池大部分线程池背后都是ThreadPoolExecutor。创建对象时字段的含义如下：</p>
<ul>
<li>corePoolSize：线程池核心线程数，最小线程数</li>
<li>maxnumPoolSize：最大线程数</li>
<li>keepAlive：线程空闲后存活时间， 0代表永远不会消失</li>
<li>timeUnit ：上面存活时间的单位  </li>
<li>第四个参数 ：==并发容器== （注意每个线程池所用到的并发容器！！）</li>
</ul>
<h3 id="基于ThreadPoolExecutor创建的线程池"><a href="#基于ThreadPoolExecutor创建的线程池" class="headerlink" title="基于ThreadPoolExecutor创建的线程池"></a>基于ThreadPoolExecutor创建的线程池</h3><h4 id="1-FixedThreadPool-固定容量线程池"><a href="#1-FixedThreadPool-固定容量线程池" class="headerlink" title="1. FixedThreadPool 固定容量线程池"></a>1. FixedThreadPool 固定容量线程池</h4><p><img src="../../../%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563971383401.png" alt="1563971383401"></p>
<p><img src="../../../%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563970723658.png" alt="1563970723658"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T05_ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">// 产生固定长度的线程池，一般线程池是用executorService接受</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123; <span class="comment">// 执行六个任务,  在只有五个固定容量的线程池中</span></span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(service); <span class="comment">// [Running, pool size = 5, active threads = 5, queued tasks = 1, completed tasks = 0]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        service.shutdown(); <span class="comment">// 未执行完毕,不会停止,只会进入停止中状态</span></span><br><span class="line">        System.out.println(service.isTerminated()); <span class="comment">// false 判断所有任务是否执行完毕</span></span><br><span class="line">        System.out.println(service.isShutdown()); <span class="comment">// true 状态是否在关闭过程中，还没关闭完</span></span><br><span class="line">        System.out.println(service);  <span class="comment">//ThreadPoolExecutor[Shutting down, pool size = 5, active threads = 5, queued tasks = 1, completed tasks = 0]</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>); <span class="comment">// 5s 后肯定执行完成了</span></span><br><span class="line"></span><br><span class="line">        System.out.println(service.isTerminated()); <span class="comment">// true </span></span><br><span class="line">        System.out.println(service.isShutdown()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(service); <span class="comment">// ThreadPoolExecutor[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 6]      </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-CachedThreadPool-可缓存的线程池"><a href="#2-CachedThreadPool-可缓存的线程池" class="headerlink" title="2. CachedThreadPool 可缓存的线程池"></a>2. CachedThreadPool 可缓存的线程池</h4><p><img src="../../../%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563970766396.png" alt="1563970766396"></p>
<p>工作原理：</p>
<ol>
<li>当有请求进入线程池内, 线程池将会启用一个线程；当再次有个请求进入线程池内, 并且上个线程未结束, 仍然会启用一个线程</li>
<li>当有线程执行完毕后,这个线程不会被清除, 而是等待任务,当有请求进入时, 直接使用缓存线程调用</li>
<li>当线程一直不被使用, 缓存最多持续1分钟(AliveTime默认值),就会被线程池销毁</li>
</ol>
<p>跟 fixedThreadPool 类似, 只不过没有上限的线程数(根据CPU所能开启的线程数，最多Integer最大值), 是一种弹性操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T08_CachedThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// pool size 为0</span></span><br><span class="line">        System.out.println(service); <span class="comment">// java.util.concurrent.ThreadPoolExecutor@7f31245a[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0]cu'</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pool size 变为2 </span></span><br><span class="line">        System.out.println(service); <span class="comment">// java.util.concurrent.ThreadPoolExecutor@7f31245a[Running, pool size = 2, active threads = 2, queued tasks = 0, completed tasks = 0]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">80</span>); <span class="comment">// 最多持续1分钟,这里sleep80s</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pool size 变为0</span></span><br><span class="line">        System.out.println(service); <span class="comment">// java.util.concurrent.ThreadPoolExecutor@7f31245a[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 2]</span></span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-SingleThreadExecutor-单线程执行器"><a href="#3-SingleThreadExecutor-单线程执行器" class="headerlink" title="3. SingleThreadExecutor 单线程执行器"></a>3. SingleThreadExecutor 单线程执行器</h4><p><img src="../../../%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563970797425.png" alt="1563970797425"></p>
<p>线程池中只有一个线程；作用：保证线程执行的==时序性==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T09_SingleThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> j = i;</span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(j + <span class="string">" "</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-ScheduledThreadPool-调度线程池"><a href="#4-ScheduledThreadPool-调度线程池" class="headerlink" title="4. ScheduledThreadPool 调度线程池"></a>4. ScheduledThreadPool 调度线程池</h4><p><img src="../../../%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563971708807.png" alt="1563971708807"></p>
<p><img src="../../../%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563970839943.png" alt="1563970839943"></p>
<p>执行定时的任务线程池,类似Delay, 可以替代Timer，且线程可以复用</p>
<p>scheduleAtFixedRate：使用固定的频率执行某个任务</p>
<p><img src="../../../%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563971897048.png" alt="1563971897048"></p>
<ul>
<li>command: 执行的任务，Runnable类型</li>
<li>initialDelay: 第一次执行延时多久执行</li>
<li>period: 每隔多久执行一次这个任务</li>
<li>unit: 时间单位</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T10_ScheduledPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">        service.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">500</span>, TimeUnit.MILLISECONDS);  </span><br><span class="line">		<span class="comment">//任务：每隔500ms打印一下线程名称</span></span><br><span class="line">		<span class="comment">//延时执行：0秒，即立即执行</span></span><br><span class="line">		<span class="comment">//每隔500ms执行一次任务</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 线程睡1000ms,而每 500 就要执行一个任务</span></span><br><span class="line">        <span class="comment">// 上个线程未执行完毕,会启用新的线程执行</span></span><br><span class="line">        <span class="comment">// 如果线程池已满,只有延时</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于ForkJoinPool创建的线程池"><a href="#基于ForkJoinPool创建的线程池" class="headerlink" title="基于ForkJoinPool创建的线程池"></a>基于ForkJoinPool创建的线程池</h3><h4 id="1-WorkStealingPool-工作窃取线程池"><a href="#1-WorkStealingPool-工作窃取线程池" class="headerlink" title="1. WorkStealingPool 工作窃取线程池"></a>1. WorkStealingPool 工作窃取线程池</h4><p><img src="../../../%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563970981753.png" alt="1563970981753"></p>
<p>工作窃取线程池：假设共有三个线程同时执行, A, B, C；当A,B线程池尚未处理任务结束,而C已经处理完毕,则C线程会从A或者B的任务队列中中窃取任务执行,这就叫工作窃取</p>
<ul>
<li>WorkStealingPool 是基于 ForkJoinPool实现的</li>
<li>work stealing 的线程全是deamon线程,即后台线程,精灵线程,守护线程</li>
</ul>
<p>deamon线程：只要虚拟机不停止，线程就不停止，一直在等待执行任务；可以通过对主线程阻塞解决</p>
<ul>
<li>workStealingPool 根据cpu核数自动启动多少个线程去执行任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T11_WorkStealingPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// CPU 核数</span></span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// workStealingPool 根据cpu核数自动启动多少个线程去执行任务</span></span><br><span class="line">        ExecutorService service = Executors.newWorkStealingPool();</span><br><span class="line">        service.execute(<span class="keyword">new</span> R(<span class="number">1000</span>));  <span class="comment">// 我的cpu核数为4 启动5个线程,其中第一个是1s执行完毕,其余都是2s执行完毕,</span></span><br><span class="line">         <span class="comment">// 有一个任务会进行等待,当第一个执行完毕后,会再次偷取第5个任务执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Runtime.getRuntime().availableProcessors(); i++) &#123;</span><br><span class="line">            service.execute(<span class="keyword">new</span> R(<span class="number">2000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">// deamon线程当main方法结束时, 此方法虽然还在后台运行,但是无输出</span></span><br><span class="line">    <span class="comment">// 可以通过对主线程阻塞解决</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">R</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> time;</span><br><span class="line"></span><br><span class="line">        R(<span class="keyword">int</span> time) &#123;</span><br><span class="line">            <span class="keyword">this</span>.time = time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(time);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  "</span> + time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-ForkJoinPool-分治线程池"><a href="#2-ForkJoinPool-分治线程池" class="headerlink" title="2. ForkJoinPool 分治线程池"></a>2. ForkJoinPool 分治线程池</h4><p><img src="../../../%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563971266019.png" alt="1563971266019"></p>
<p>“分而治之”的线程池：将一个任务拆分多个任务执行(可以无限切分),然后将结果合并</p>
<ul>
<li>比如大量的并行计算, 如下: 求100_0000个数字之和, 使用多线程</li>
</ul>
<p>ForkJoinPool中执行的任务一定是ForkJoinTask任务，可以用RecursiveAction、RecursiveTask两种继承ForkJoinTask的类进行实现，两者的区别：</p>
<ul>
<li><p>RecursiveAction: 递归操作 没有返回值</p>
<ul>
<li>RecursiveTask: 递归操作,有返回值</li>
<li>只有RecursiveTask才有join，join方法可以阻塞；RecursiveAction没有join，只能通过in.read()阻塞</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T12_ForkJoinPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100_0000</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_NUM = <span class="number">5_0000</span>; <span class="comment">// 每个线程最多可以运行5万个数字相加</span></span><br><span class="line">    <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化这100_000个数字, 每个数字范围在100之内</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = random.nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有数字和, 事先计算:</span></span><br><span class="line">        <span class="comment">//System.out.println(Arrays.stream(nums).sum()); // 使用单线程stream api 进行求和</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//无返回值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTask</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line">        </span><br><span class="line">        AddTask(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 进行计算</span></span><br><span class="line">            <span class="comment">// 如果计算的数的和的范围 小于 MAX_NUM, 进行计算,否则进行 fork </span></span><br><span class="line">            <span class="keyword">if</span> (end - start &lt;= MAX_NUM) &#123;</span><br><span class="line">                <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                    sum += nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"sum = "</span> + sum);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> middle = (end - start) / <span class="number">2</span>;</span><br><span class="line">                AddTask subTask1 = <span class="keyword">new</span> AddTask(start, middle);</span><br><span class="line">                AddTask subTask2 = <span class="keyword">new</span> AddTask(middle, end);</span><br><span class="line">                subTask1.fork();</span><br><span class="line">                subTask2.fork();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有返回值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTask2</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line">        </span><br><span class="line">        AddTask2(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (end - start &lt;= MAX_NUM) &#123;</span><br><span class="line">                <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                    sum += nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> middle = start + (end - start) / <span class="number">2</span>; <span class="comment">// 注意这里，如果有问题，会抛出java.lang.NoClassDefFoundError: Could not initialize class java.util.concurrent.locks.AbstractQueuedSynchronizer$Node 异常</span></span><br><span class="line">                AddTask2 subTask1 = <span class="keyword">new</span> AddTask2(start, middle);</span><br><span class="line">                AddTask2 subTask2 = <span class="keyword">new</span> AddTask2(middle, end);</span><br><span class="line">                subTask1.fork();</span><br><span class="line">                subTask2.fork();</span><br><span class="line">                <span class="keyword">return</span> subTask1.join() + subTask2.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ForkJoinPool fjp = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        AddTask2 task = <span class="keyword">new</span> AddTask2(<span class="number">0</span>, nums.length);</span><br><span class="line">        fjp.execute(task);</span><br><span class="line">        System.out.println(task.join());<span class="comment">//join是阻塞的，不需要in.read进行阻塞</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//System.in.read();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h3 id="1-监控元素个数"><a href="#1-监控元素个数" class="headerlink" title="1.监控元素个数"></a>1.监控元素个数</h3><p>实现一个容器，提供两个方法，add，size； 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到达5时，线程2给出提示并结束</p>
<p><strong>a) wait/notify</strong></p>
<p>wait()、notify/notifyAll() 方法是Object的本地final方法，无法被重写；一般配合synchronized 关键字使用</p>
<ul>
<li>wait ：让获取某个对象的锁的线程等待，并且让线程释放当前对象的锁</li>
<li>notify：当另一个线程获得这个对象锁后，可以使用notify方法唤醒在这个对象上等待的线程（具体是哪个线程由CPU调度决定）；因为线程不能自己叫醒自己(暂时不可实现），所以只能让另外一个线程执行notify方法唤醒等待线程</li>
<li>notifyall：叫醒所有正在等待的线程</li>
<li>notify和notifyall唤醒等待线程后==不会立即释放锁==</li>
<li>==wait()与notify() 方法的调用必须在同步代码块中==</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object ele)</span> </span>&#123;</span><br><span class="line">        list.add(ele);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyContainer3 container = <span class="keyword">new</span> MyContainer3();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">		<span class="comment">//启动监控元素个数的线程t2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"t2 启动"</span>);</span><br><span class="line">                <span class="keyword">if</span> (container.size() != <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"监测到容器长度为5，线程2立即退出"</span>);</span><br><span class="line">                <span class="comment">//退出之前又唤醒等待t1线程，让它继续运行</span></span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//启动元素增加的线程t1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    container.add(<span class="keyword">new</span> Object());</span><br><span class="line">                    System.out.println(<span class="string">"add "</span> + i);</span><br><span class="line">                    <span class="comment">// 当长度为5时，通知 t2 进行退出</span></span><br><span class="line">                    <span class="keyword">if</span> (container.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                        lock.notify(); <span class="comment">// notify 不会释放锁，即便通知t2，t2也获取不到锁</span></span><br><span class="line">                        <span class="comment">// 可以在wait一下，将锁释放，再让t2通知t1继续执行</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b) CountDownLatch实现</p>
<p>使用Countdown(往下数)Latch(门闩)替代 wait notify来进行通信：通信简单，同时也可以指定等待时间</p>
<ul>
<li>CountDownLatch中使用await和countDown 方法替代 wait 和 notify</li>
<li>门闩不能保证可见性，不是一种同步方式，只是一种线程通信方式，保证不了可见性</li>
<li>CountDownLatch不涉及锁定，当count值为0时，门闩就会打开，当前线程继续运行</li>
</ul>
<p>所以当不涉及同步，只涉及线程通信的时候，用synchronized + wait + notify 就显得太重了，利用CountDownLatch+volatile替代效率更高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyContainer5 container = <span class="keyword">new</span> MyContainer5();</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"t2 启动"</span>);</span><br><span class="line">            <span class="keyword">if</span> (container.size() != <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    latch.await();</span><br><span class="line">                    <span class="comment">// 指定等待时间</span></span><br><span class="line">                    <span class="comment">//latch.await(5000, TimeUnit.MILLISECONDS);</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"监测到容器长度为5，线程2立即退出"</span>);</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"t1 启动"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                container.add(<span class="keyword">new</span> Object());</span><br><span class="line">                System.out.println(<span class="string">"add "</span> + i);</span><br><span class="line">                <span class="comment">// 当长度为5时，撤掉一个门闩，此时门闩为0，门会打开，即t2会执行</span></span><br><span class="line">                <span class="keyword">if</span> (container.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="comment">//减1，变为0，门闩打开，线程2运行</span></span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-生产者与消费者"><a href="#2-生产者与消费者" class="headerlink" title="2.生产者与消费者"></a>2.生产者与消费者</h3><p>实现方法：</p>
<h4 id="a-wait-notify"><a href="#a-wait-notify" class="headerlink" title="a) wait/notify"></a>a) wait/notify</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer1</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;T&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (MAX == count) &#123; <span class="comment">// 如果容量最大，释放锁等待    </span></span><br><span class="line">            <span class="comment">///【问题1.这里为什么使用while，而不是使用if？？？】</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则 put </span></span><br><span class="line">        list.add(t);</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">this</span>.notifyAll(); <span class="comment">// 通知消费者线程，可以消费了</span></span><br><span class="line">        <span class="comment">// 【问题2.这里为什么调用 notifyAll 而不是 notify ？】</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (list.size() == <span class="number">0</span>) &#123; <span class="comment">// 如果容量为空，释放锁等待  </span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则获取</span></span><br><span class="line">        T t = list.removeFirst();</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">this</span>.notifyAll(); <span class="comment">// 通知生产者线程生产</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【问题1. 为什么使用while 而不是使用 if 】</strong><br>①上述代码中，在容器已满的情况下，put方法会wait等待，当容器中的元素被消费者消费了一部分，就会唤醒所有的生产者线程</p>
<p>②如果用if：生产者线程会在wait后继续向下执行，直接执行list.add(t)，那么多个生产者线程执行list.add() 就有可能出现数据一致性的问题。<br>③如果使用while：则会先循环判断有没有空位生产，再决定要不要list.add(t)，就避免了这些问题。</p>
<p>【<strong>不是有锁吗？为什么会需要循环判断？</strong>】<br>线程wait之后，锁就会失去；线程再次被唤醒时，并且得到锁之后因为没有循环判断，生产者线程就不会判断容器是否有空位放，因而会直接加入到容器中，造成多个线程同时向容器中生产东西。</p>
<p><strong>【问题2. 为什么调用 notifyAll 而不是 notify ？】</strong><br>因为notify有可能再次叫醒一个生产者线程，而不是去唤醒消费者线程</p>
<p>上述方法虽然可以实现生产消费模型，但是notifyall唤醒所有线程的方法效率较低，我们可以使用以下方法进行改进。</p>
<h4 id="b-lock与Condition"><a href="#b-lock与Condition" class="headerlink" title="b) lock与Condition"></a>b) lock与Condition</h4><p>Condition可以替代传统的线程间通信，用await()替代wait，用signal替代notify()，用signalAll()替代notifyAll()。condition可以为==多个线程之间创建不同的condition==，也就是可以==精确唤醒某些线程==</p>
<p>注意：condition()是被绑定到Lock上面的，要创建一个Lock的conditon，需要用newCondition 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">consumer2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;T&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> Max = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition consumer = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition produce = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (Max == count) &#123;</span><br><span class="line">                produce.await();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(t);</span><br><span class="line">            ++count;</span><br><span class="line">            consumer.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                consumer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            t = list.removeFirst();</span><br><span class="line">            --count;</span><br><span class="line">            produce.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        consumer2&lt;String&gt; consumer = <span class="keyword">new</span> consumer2();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">                    System.out.println(consumer.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"consumer"</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"produce"</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-火车票销售"><a href="#3-火车票销售" class="headerlink" title="3. 火车票销售"></a>3. 火车票销售</h3><p>题目：有N张火车票，每张票都有一个编号，同时有10个窗口对外售票，请写一个模拟程序</p>
<ol>
<li>第一个程序：线程同步不安全，导致重复销售，超量销售等问题</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; tickets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//静态方法，类加载时会自动加载</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            tickets.add(<span class="string">"票-"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (tickets.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"销售了："</span> + tickets.remove(<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>第二个程序：使用Vector同步容器替换List容器</p>
<p>依然不能解决问题，判断和操作依然是复合操作，即是分离的，不是原子操作</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Vector&lt;String&gt; tickets = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            tickets.add(<span class="string">"票-"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (tickets.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将问题方法，睡1s</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"销售了："</span> + tickets.remove(<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>第三个程序：使用synchronized，可以解决问题，但是效率不高</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; tickets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            tickets.add(<span class="string">"票-"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (tickets.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// sychronized 保证了原子性，但是效率低</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (tickets) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"销售了："</span> + tickets.remove(<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>第四个程序：使用同步队列，解决问题，效率较好</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ConcurrentLinkedQueue&lt;String&gt; queue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            queue.add(<span class="string">"票-"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    String t = queue.poll(); <span class="comment">// 取出头，拿不到就是空值</span></span><br><span class="line">                    <span class="comment">//就算线程在这里了被另一个线程打断，这个线程还是可以重新回去poll一下，保证有效</span></span><br><span class="line">                    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> System.out.println(<span class="string">"销售了："</span> + t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考博文</p>
<p><a href="https://www.jianshu.com/p/d52fea0d6ba5" target="_blank" rel="noopener">java内存模型以及happens-before规则</a></p>
<h1 id="回答："><a href="#回答：" class="headerlink" title="回答："></a>回答：</h1><ol>
<li>JVM内存中的堆和方法区是线程共享的，那么他们存储的数据是可以被多个线程同时操作的，如果我们不加以并发控制，那么会造成数据不一致的问题。</li>
<li>并发，我了解的有几块内容：并发关键字、并发容器和线程池</li>
<li>并发关键字有synchronized、volatile、ReentranLock等，synchronized可以锁定方法或代码块中的实例对象，类对象来实现并发控制，保证原子性、可见性、有序性；除了volatile不能保证原子性外，它的作用与synchronized一样；而ReentranLock比synchronized更加灵活，是个手动锁，可以尝试锁定、还可设置公平锁</li>
<li>并发容器有ConcurrentHahsMap高并发的map的高并发的队列：</li>
</ol>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://qinnsang.github.io/2019/08/31/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qinnsang">
      <meta itemprop="description" content="Keep study">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qinnsang's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/31/JVM/" class="post-title-link" itemprop="url">未命名</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-31 11:38:58" itemprop="dateCreated datePublished" datetime="2019-08-31T11:38:58+08:00">2019-08-31</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-28 12:22:43" itemprop="dateModified" datetime="2019-07-28T12:22:43+08:00">2019-07-28</time>
              </span>
            
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span></span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span></span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java体系"><a href="#Java体系" class="headerlink" title="Java体系"></a>Java体系</h1><p><img src="assets/1563978475792.png" alt="1563978475792"></p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="1-Run-Time-Data-Areas-运行时数据区"><a href="#1-Run-Time-Data-Areas-运行时数据区" class="headerlink" title="1. Run-Time Data Areas 运行时数据区"></a>1. Run-Time Data Areas 运行时数据区</h2><p><img src="assets/1564068841939.png" alt="1564068841939"></p>
<p>JAVA虚拟机定义了各种用于程序执行时的运行时数据区：</p>
<p>a) 一些数据区是与<strong>虚拟机的生命周期</strong>一致的：创建于虚拟机开始运行时，销毁于虚拟机退出时</p>
<p>b) 一些数据区是与<strong>线程生命周期</strong>一致的：创建于线程创建，毁于线程推出</p>
<p>在数据区中：</p>
<p>==线程私有：Program Counter Register、JVM Stacks、Native Method Stacks==（无GC）</p>
<p>==线程共享：Heap、Method Area==（有GC）</p>
<p><img src="assets/1564193357157.png" alt="1564193357157"></p>
<h3 id="1-1-Program-Counter-Register-程序计数器"><a href="#1-1-Program-Counter-Register-程序计数器" class="headerlink" title="1.1 Program Counter Register 程序计数器"></a>1.1 Program Counter Register 程序计数器</h3><p>程序计数器是指CPU中的寄存器</p>
<ul>
<li><p>执行java方法时，程序计数器是有值的，存储的是==当前执行的字节码指令的地址==（保存下一条指令的所在存储单元的地址）CPU根据保存的指令地址找到指令，然后在执行。目的是防止多线程执行时出现干扰，单线程的话可以没有PC</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9506169-32bfeb090c356924.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/860/format/webp" alt="img"></p>
</li>
<li><p>执行native本地方法时，程序计数器的值为空（Undefined）：因为native方法是java直接调用本地C/C++库进行实现，那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。</p>
</li>
<li><p>程序计数器PC有足够的空间存储返回地址信息，占用的内存很小，所以PC是唯一一个JVM中没有OutOfMemoryError的区域。</p>
</li>
</ul>
<h3 id="1-2-Native-Method-Stacks-本地方法栈"><a href="#1-2-Native-Method-Stacks-本地方法栈" class="headerlink" title="1.2 Native Method Stacks 本地方法栈"></a>1.2 Native Method Stacks 本地方法栈</h3><ul>
<li><p>作用场景：在程序调用或JVM==调用本地方法==（非java语言编写，不受JVM管理）接口(Native)时候启用，即本地方法栈将会在每个线程创建的是将被分配内存</p>
</li>
<li><p>存储的是<strong>本地方法的数据</strong></p>
<p><img src="assets/1564061794205.png" alt="1564061794205"></p>
<p>​                                        <u>如上图的线程的start()方法创建时会调用一个native方法</u></p>
</li>
<li><p>异常行为</p>
<ul>
<li>栈溢出：由于线程执行需要更大的栈而产生的异常，即线程过程执行需要存储大量内容而引起的</li>
<li>内存溢出：由于内存不足无法分配给栈而导致的异常</li>
</ul>
</li>
</ul>
<h3 id="1-3-JVM-Stacks-虚拟机栈"><a href="#1-3-JVM-Stacks-虚拟机栈" class="headerlink" title="1.3 JVM Stacks 虚拟机栈"></a>1.3 JVM Stacks 虚拟机栈</h3><p>每个Java虚拟机线程都有一个私有的Java虚拟机栈，JVM栈是运行的单位</p>
<ul>
<li>生命周期：因栈是线程私有的，所以与线程的生命周期一致：==随线程创建，随线程结束销毁==</li>
<li>存储数据：Java虚拟机栈中==存储栈帧==：当前线程运行时所需要的局部变量、对象的引用、计算的结果、返回信息等</li>
<li>栈的行为：压入(push)和弹出(pop)栈帧</li>
<li>存取类型：压入和弹出栈帧采用FILO先进后出，因为是调用方法总是先完成。 </li>
<li>Java虚拟机栈的内存不需要是连续的</li>
<li>JVM默认给每个栈分配的空间是1M，也可以自己在configurations中设置；所以<strong>如果分配给每个栈的内存越小，那么JVM所支撑的线程就越多</strong></li>
</ul>
<p><img src="assets/1564060504629.png" alt="1564060504629"></p>
<h4 id="1-3-1-Frames-栈帧"><a href="#1-3-1-Frames-栈帧" class="headerlink" title="1.3.1 Frames 栈帧"></a>1.3.1 Frames 栈帧</h4><p><img src="assets/1564194202169.png" alt="1564194202169"></p>
<ul>
<li>存储数据：<ul>
<li>局部变量表：基本数据类型、变量对象的引用（指针）</li>
<li>可操作数栈：方法执行过程中的结果</li>
<li>运行环境区：动态连接、方法返回相关信息、抛出异常</li>
</ul>
</li>
<li>生命周期：每个方法都有一个栈帧，每次调用一个方法时就会创建一个栈帧，方法调用完后栈帧就被销毁，无论方法是否时正常结束或抛出异常。</li>
<li>局部变量与操作数栈的大小在编译时就确定了</li>
<li>当前栈：在线程运行时，仅有且只有一个正在运行的方法的栈帧；它对应的方法就是当前运行的方法，当前运行的类就是当前类。在局部变量和操作数栈上的操作是和当前栈帧相关的</li>
<li>栈帧会在方法调用另外一个方法或方法结束后停止。当一个方法被调用且控制权转为这个新的方法时，那么一个新的栈帧就会被创建成为当前栈帧。<strong>在方法返回时，当前栈帧就会将返回结果传递给调用者的栈帧</strong>（如果有的话）这个栈帧就会被之前的那个栈帧取代成为当前栈帧。</li>
</ul>
<h5 id="1-3-1-1-Local-Variables-局部变量表"><a href="#1-3-1-1-Local-Variables-局部变量表" class="headerlink" title="1.3.1.1 Local Variables 局部变量表"></a>1.3.1.1 Local Variables 局部变量表</h5><ul>
<li>存储局部变量、对象的引用</li>
<li>一个单独的局部变量可以存储基本数据类型的值、引用，long和double型可以用两个局部变量来存储</li>
<li>局部变量使用索引来表示的，第一个局部变量的索引是0。一个整数可以当做一个索引，只要整数在[0，局部变量表的长度] 区域内。一个long、double类型的值占据两个连续的局部变量</li>
<li>虚拟机通过局部变量在方法调用过程中传递参数：<ul>
<li>在类方法调用时，任何参数都在从局部变量0开始的连续局部变量中传递。</li>
<li>在实例方法调用中，局部变量0始终用于存储==对调用实例方法的对象的引用==（这在Java编程语言中）。 随后，任何参数都在从局部变量1开始的连续局部变量中传递。</li>
</ul>
</li>
</ul>
<h5 id="1-3-1-2-operand-stack-操作数栈"><a href="#1-3-1-2-operand-stack-操作数栈" class="headerlink" title="1.3.1.2 operand stack 操作数栈"></a>1.3.1.2 operand stack 操作数栈</h5><ul>
<li><p>每个栈帧包含一个采用LIFO先进后出的操作数栈</p>
</li>
<li><p>存储执行过程中的结果：Java虚拟机提供指令，将局部变量或常量的==值或内容加载到操作数栈==上（不是局部变量和常量加载到操作数栈中）</p>
<p>Java虚拟机指令从操作数栈中获取操作数，对它们进行操作，并将结果推回操作数栈中。例如：iadd指令将两个int值相加，于是将操作数栈的前两个int值相加，将结果压入栈中，并且两个int值都从操作数堆栈中弹出删除。</p>
</li>
<li><p>操作数栈具有相关联的深度：其中long或double类型的值占据两个单位深度，而其他类型的值占一个单位。</p>
</li>
</ul>
<h5 id="方法调用时可操作数栈与局部变量的互动"><a href="#方法调用时可操作数栈与局部变量的互动" class="headerlink" title="方法调用时可操作数栈与局部变量的互动"></a>方法调用时可操作数栈与局部变量的互动</h5><p><img src="assets/1564237853677.png" alt="1564237853677"></p>
<ol>
<li>调用add()方法时创建add方法的栈帧</li>
<li>iconst_1 ：把int类型的1压入可操作数栈中</li>
<li>istore_1： 将可操作数栈中的int类型1存入局部变量表中的第一个位置：结果a＝1；同理，b=2</li>
<li>iload_1：将局部变量的第1、2个位置的数（即a、b的值）加载到操作数栈中</li>
<li>执行iadd加法：将1、2从栈中弹出相加，并将结果3压入栈中</li>
<li>istore_3 ：将int类型的3压入局部变量表中</li>
<li>iload_3：将局部变量的第3个位置的数（即c的值）加载到操作数栈中</li>
<li>return ：返回</li>
</ol>
<h5 id="1-3-1-3-Dynamic-Linking-动态链接"><a href="#1-3-1-3-Dynamic-Linking-动态链接" class="headerlink" title="1.3.1.3 Dynamic Linking 动态链接"></a>1.3.1.3 Dynamic Linking 动态链接</h5><p>即多态：动态链接将抽象的引用转化为具体的引用</p>
<p><img src="assets/1564195802998.png" alt="1564195802998"></p>
<p><img src="assets/1564195847515.png" alt="1564195847515"></p>
<h5 id="1-3-1-4-Normal-Method-Invocation-Completion-方法正常结束"><a href="#1-3-1-4-Normal-Method-Invocation-Completion-方法正常结束" class="headerlink" title="1.3.1.4 Normal Method Invocation Completion 方法正常结束"></a>1.3.1.4 Normal Method Invocation Completion 方法正常结束</h5><ul>
<li>当被调用的方法执行到return返回指令时，必须返回适合的值类型（如果有的话）</li>
<li>当调用方法正常结束时：<ol>
<li>当前帧用于恢复调用者的状态，包括其局部变量和操作数堆栈</li>
<li>调用者的程序计数器适当增加以跳过调用方法指令：比如调用者执行add()方法时是第9行，那么调用方法结束后PC+1，就变为第10行，这样调用者就会执行第10行的操作）</li>
<li>然后执行在调用方法的栈帧会将正常返回的值（如果有）压入该帧的操作数堆栈。</li>
</ol>
</li>
</ul>
<h5 id="1-3-1-5-Abrupt-Method-Invocation-Completion-方法异常结束"><a href="#1-3-1-5-Abrupt-Method-Invocation-Completion-方法异常结束" class="headerlink" title="1.3.1.5 Abrupt Method Invocation Completion 方法异常结束"></a>1.3.1.5 Abrupt Method Invocation Completion 方法异常结束</h5><ul>
<li><p>非正常结束的调用方法：抛出异常或错误</p>
</li>
<li><p>如果当前方法没有捕获到异常，则会导致方法调用突然结束。 这种方法结束调用时永远不会向其调用者返回值</p>
</li>
</ul>
<p>讲完线程私有，接下来的就是线程共享的：</p>
<p><img src="assets/1563982497370.png" alt="1563982497370"></p>
<h3 id="1-4-Heap-堆"><a href="#1-4-Heap-堆" class="headerlink" title="1.4 Heap 堆"></a>1.4 Heap 堆</h3><p>堆是存储的单位，栈是运行的单位</p>
<ul>
<li>存储内容：记录所有实例对象和数组</li>
<li>生命周期：堆随虚拟机开始时创建</li>
<li>堆内存不连续</li>
<li>垃圾收集器管理的主要区域：当方法结束后，虚拟机栈会立即消失，而堆内存存储的对象的引用不会立即消失，而是等到gc进行回收</li>
<li>GC回收原则：当没有任何对象引用指向堆内存里面的对象时</li>
</ul>
<p><img src="assets/1564197745665.png" alt="1564197745665"></p>
<p><img src="assets/1564197661045.png" alt="1564197661045"></p>
<ol>
<li>从内存回收的角度来看，由于现在的收集器基本都采用分代收集算法，所以堆又可以细分成：新生代和老年代，新生代里面有分为：Eden空间、From Survivor空间、To Survivor空间。</li>
<li>默认情况下，新生代中Eden空间与Survivor空间的比例是8:1，可以使用参数-XX:SurvivorRatio对其进行配置。大多数情况下，新生对象在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，则触发一次Minor GC，将对象Copy到Survivor区，如果Survivor区没有足够的空间来容纳，则会通过分配担保机制提前转移到老年代去。</li>
<li>何为分配担保机制？在发送Minor GC前，JVM会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果是，那么可以确保Minor GC是安全的，如果不是，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果小于，直接进行Full GC，如果大于，将尝试着进行一次Minor GC，Minor GC失败才会触发Full GC。注：不同版本的JDK，流程略有不同。</li>
<li>Survivor区作为Eden区和老年代的缓冲区域，常规情况下，在Survivor区的对象经过若干次垃圾回收仍然存活的话，才会被转移到老年代。JVM通过这种方式，将大部分命短的对象放在一起，将少数命长的对象放在一起，分别采取不同的回收策略。</li>
</ol>
<h3 id="1-5-Method-Area（meta-space）方法区"><a href="#1-5-Method-Area（meta-space）方法区" class="headerlink" title="1.5 Method Area（meta space）方法区"></a>1.5 Method Area（meta space）方法区</h3><p><strong>存放数据</strong>：</p>
<ol>
<li><p>每个class的信息:</p>
<ul>
<li>类名</li>
</ul>
<ul>
<li><p>字段信息</p>
<p>每个字段名字、类型(如类的全路径名、类型或接口) 、修饰符（如public、abstract、final）、属性</p>
</li>
<li><p>方法信息</p>
<p>每个方法的名字、返回类型、参数类型(按顺序)、修饰符、属性</p>
</li>
</ul>
</li>
<li><p>运行时常量池：全局变量、所有常量、字段引用、方法引用、属性</p>
</li>
<li><p>方法代码</p>
<p>每个方法的字节码、操作数栈大小、局部变量大小、局部变量表、异常表和每个异常处理的开始位置、结 束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</p>
</li>
<li><p>类加载器引用(classLoader)</p>
</li>
</ol>
<p>方法区直接放在本地的物理内存（直接内存），其他的都放在JVM内存中</p>
<ul>
<li>如果内存不足会报内存不足错误</li>
</ul>
<h4 id="1-5-1-Run-Time-Constant-Pool-运行时常量池"><a href="#1-5-1-Run-Time-Constant-Pool-运行时常量池" class="headerlink" title="1.5.1 Run-Time Constant Pool 运行时常量池"></a>1.5.1 Run-Time Constant Pool 运行时常量池</h4><p>方法区的一部分，存放在编译期间，就可以确定下来的值</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14211474-15d9dfb21ffa15ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p>
<ul>
<li><p>字面量：如final、String及其包装类的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;<span class="comment">//1就是字面量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>符号引用：由于不知道所引用类的实际地址，而以符号的形式表现出来的</p>
<p>与直接引用不同，直接引用直接利用指针指向具体的实际地址</p>
<p><img src="assets/1564238826806.png" alt="1564238826806"></p>
</li>
</ul>
<ul>
<li>创建时间：当Java虚拟机创建类或接口时，将构造类或接口的运行时常量池；除了编译产生能存入，运行期间也能将新的常量放入池中(String.intern())</li>
<li>节省内存空间：常量池中如果有对应的字符串，那么则返回该对象的引用，从而不必再次创建一个新对象。</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.jpg"
      alt="qinnsang">
  <p class="site-author-name" itemprop="name">qinnsang</p>
  <div class="site-description" itemprop="description">Keep study</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/QinnSang" title="GitHub &rarr; https://github.com/QinnSang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://cxxin1998@163.com" title="E-Mail &rarr; https://cxxin1998@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qinnsang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数"></span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.3.0</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/pisces.js?v=7.3.0"></script>

<script src="/js/next-boot.js?v=7.3.0"></script>



  





















  

  

  

</body>
</html>
