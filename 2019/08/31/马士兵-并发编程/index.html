<!DOCTYPE html>





<html lang="Zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Kopieren',
      copy_success: 'Kopiert',
      copy_failure: 'Kopieren fehlgeschlagen'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="==内存模型抽象结构 1. Java内存模型Java内存模型是==内存共享==的并发模型，线程之间主要通过读-写共享变量来完成通信。 2. 共享变量 共享变量：==堆内存==中的变量所有线程均可访问到，是可以共享的：所有==实例域，静态域和数组元素== 非共享变量：局部变量，方法定义参数和异常处理器参数不会在线程间共享 共享数据会出现线程安全的问题，而非共享数据不会出现线程安全的问题  3. JM">
<meta property="og:type" content="article">
<meta property="og:title" content="qinnsang&#39;s blog">
<meta property="og:url" content="https://qinnsang.github.io/2019/08/31/马士兵-并发编程/index.html">
<meta property="og:site_name" content="qinnsang&#39;s blog">
<meta property="og:description" content="==内存模型抽象结构 1. Java内存模型Java内存模型是==内存共享==的并发模型，线程之间主要通过读-写共享变量来完成通信。 2. 共享变量 共享变量：==堆内存==中的变量所有线程均可访问到，是可以共享的：所有==实例域，静态域和数组元素== 非共享变量：局部变量，方法定义参数和异常处理器参数不会在线程间共享 共享数据会出现线程安全的问题，而非共享数据不会出现线程安全的问题  3. JM">
<meta property="og:locale" content="Zh-Hans">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2615789-8c0b960a27af28db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/792/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2615789-08f16aeac7e0977d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/993/format/webp">
<meta property="og:image" content="https://qinnsang.github.io/2019/%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563971383401.png">
<meta property="og:image" content="https://qinnsang.github.io/2019/%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563970723658.png">
<meta property="og:image" content="https://qinnsang.github.io/2019/%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563970766396.png">
<meta property="og:image" content="https://qinnsang.github.io/2019/%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563970797425.png">
<meta property="og:image" content="https://qinnsang.github.io/2019/%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563971708807.png">
<meta property="og:image" content="https://qinnsang.github.io/2019/%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563970839943.png">
<meta property="og:image" content="https://qinnsang.github.io/2019/%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563971897048.png">
<meta property="og:image" content="https://qinnsang.github.io/2019/%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563970981753.png">
<meta property="og:image" content="https://qinnsang.github.io/2019/%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563971266019.png">
<meta property="og:updated_time" content="2019-08-06T14:22:13.375Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="qinnsang&#39;s blog">
<meta name="twitter:description" content="==内存模型抽象结构 1. Java内存模型Java内存模型是==内存共享==的并发模型，线程之间主要通过读-写共享变量来完成通信。 2. 共享变量 共享变量：==堆内存==中的变量所有线程均可访问到，是可以共享的：所有==实例域，静态域和数组元素== 非共享变量：局部变量，方法定义参数和异常处理器参数不会在线程间共享 共享数据会出现线程安全的问题，而非共享数据不会出现线程安全的问题  3. JM">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/2615789-8c0b960a27af28db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/792/format/webp">
  <link rel="canonical" href="https://qinnsang.github.io/2019/08/31/马士兵-并发编程/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title> | qinnsang's blog</title>
  <meta name="generator" content="Hexo 3.9.0">
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="Zh-Hans">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">qinnsang's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Navigationsleiste an/ausschalten">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Startseite</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>Über</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Schlagwörter<span class="badge">0</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Kategorien<span class="badge">0</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archiv<span class="badge">2</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://qinnsang.github.io/2019/08/31/马士兵-并发编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qinnsang">
      <meta itemprop="description" content="Keep study">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qinnsang's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2019-08-31 11:40:15" itemprop="dateCreated datePublished" datetime="2019-08-31T11:40:15+08:00">2019-08-31</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2019-08-06 22:22:13" itemprop="dateModified" datetime="2019-08-06T22:22:13+08:00">2019-08-06</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>==内存模型抽象结构</p>
<h2 id="1-Java内存模型"><a href="#1-Java内存模型" class="headerlink" title="1. Java内存模型"></a>1. Java内存模型</h2><p>Java内存模型是==内存共享==的并发模型，线程之间主要通过读-写共享变量来完成通信。</p>
<h2 id="2-共享变量"><a href="#2-共享变量" class="headerlink" title="2. 共享变量"></a>2. 共享变量</h2><ul>
<li>共享变量：==堆内存==中的变量所有线程均可访问到，是可以共享的：所有==实例域，静态域和数组元素==</li>
<li>非共享变量：局部变量，方法定义参数和异常处理器参数不会在线程间共享</li>
<li><strong>共享数据会出现线程安全的问题，而非共享数据不会出现线程安全的问题</strong></li>
</ul>
<h2 id="3-JMM抽象结构模型"><a href="#3-JMM抽象结构模型" class="headerlink" title="3. JMM抽象结构模型"></a>3. JMM抽象结构模型</h2><p>① 由于CPU的处理速度和主存的读写速度不是一个量级的，为了平衡这种巨大的差距，每个CPU都会有缓存。</p>
<p>② 因此，<strong>共享变量</strong>会先放在<strong>主存</strong>中</p>
<p>③ ==每个线程都有属于自己的工作内存==，并且会把位于==主存中的共享变量拷贝到自己的工作内存==，线程之后的读写操作均使用位于工作内存的变量副本，并在<strong>某个时刻</strong>将工作内存的==变量副本写回到主存==中去。</p>
<p>③ JMM就从抽象层次定义了这种方式，并且JMM决定了一个线程对共享变量的写入何时对其他线程是可见的。<br><img src="https://upload-images.jianshu.io/upload_images/2615789-8c0b960a27af28db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/792/format/webp" alt="img"></p>
<p>如图为JMM抽象示意图，线程A和线程B之间要完成通信的话，要经历如下两步：</p>
<ol>
<li>线程A从主内存中将共享变量读入线程A的工作内存后并进行操作，之后将数据重新写回到主内存中；</li>
<li>线程B从主存中读取最新的共享变量</li>
</ol>
<p>为了避免发生脏读，使用线程并发控制机制</p>
<h1 id="线程并发"><a href="#线程并发" class="headerlink" title="线程并发"></a>线程并发</h1><h2 id="Synchronized互斥锁"><a href="#Synchronized互斥锁" class="headerlink" title="Synchronized互斥锁"></a>Synchronized互斥锁</h2><p>锁信息记录在堆内存对象中的，不是在栈引用中</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2615789-08f16aeac7e0977d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/993/format/webp" alt="img"></p>
<h3 id="被锁对象"><a href="#被锁对象" class="headerlink" title="被锁对象"></a>被锁对象</h3><h4 id="1-代码块中的实例对象Object"><a href="#1-代码块中的实例对象Object" class="headerlink" title="1. 代码块中的实例对象Object"></a>1. 代码块中的实例对象Object</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 任何线程要执行下面的代码，都必须先拿到lock锁</span></span><br><span class="line">          					  <span class="comment">// 如果lock已经被锁定，其他线程再进入时，就会进行阻塞等待</span></span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当代码块执行完毕后，锁就会被释放，然后被其他线程获取</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-代码块中的类实例对象-this"><a href="#2-代码块中的类实例对象-this" class="headerlink" title="2. 代码块中的类实例对象 this"></a>2. 代码块中的类实例对象 this</h4><p>由于每次使用锁都要newObject，比较麻烦，可以使用this代替object锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">// 任何线程要执行下面的代码，必须先拿到this锁</span></span><br><span class="line">           					 <span class="comment">// synchronized 锁定的不是代码块，而是 this 类的实例对象</span></span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-代码块中的类对象"><a href="#3-代码块中的类对象" class="headerlink" title="3. 代码块中的类对象"></a>3. 代码块中的类对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (T.class) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronize不仅可以放在代码块中，还可以放在方法上</p>
<h4 id="4-实例方法上的类实例对象"><a href="#4-实例方法上的类实例对象" class="headerlink" title="4. 实例方法上的类实例对象"></a>4. 实例方法上的类实例对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123; <span class="comment">// 等同于 synchronized (this) &#123; </span></span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-静态方法上的类对象"><a href="#5-静态方法上的类对象" class="headerlink" title="5. 静态方法上的类对象"></a>5. 静态方法上的类对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123; <span class="comment">// 等同于 synchronized (c_004.T.class) &#123; </span></span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul>
<li>==原子性==：一个操作是不可中断的，要么全部执行成功要么全部执行失败</li>
<li>==可见性==：当一个线程修改了共享变量后，其他线程能够立即得知这个修改</li>
<li>==有序性==：表示锁在同一时刻只能由一个线程进行获取，当锁被占用后，其他线程只能等待。</li>
</ul>
<h3 id="同步方法的调用问题"><a href="#同步方法的调用问题" class="headerlink" title="同步方法的调用问题"></a>同步方法的调用问题</h3><h4 id="1-同步与非同步方法是否可以同时调用"><a href="#1-同步与非同步方法是否可以同时调用" class="headerlink" title="1. 同步与非同步方法是否可以同时调用"></a>1. 同步与非同步方法是否可以同时调用</h4><p>可以，虽然锁的是整个对象，但是内部的方法不是同步的话也可以访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" m1 start"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" m1 end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" m2 start"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" m2 end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">new</span> Thread(t::m1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t::m2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//Thread-0 m1 start</span></span><br><span class="line"><span class="comment">////Thread-1 m2 start</span></span><br><span class="line"><span class="comment">////Thread-1 m2 end </span></span><br><span class="line"><span class="comment">////Thread-0 m1 end</span></span><br></pre></td></tr></table></figure>

<h4 id="2-一个同步方法是否可以调用另一个同步方法"><a href="#2-一个同步方法是否可以调用另一个同步方法" class="headerlink" title="2. 一个同步方法是否可以调用另一个同步方法"></a>2. 一个同步方法是否可以调用另一个同步方法</h4><p>synchronized 是可重入锁：即一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请时仍然会得到该对象的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m1 start "</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">" m2"</span>); <span class="comment">// 这句话会打印，调用m2时，不会发生死锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-子类是否可以调用父类的同步方法"><a href="#3-子类是否可以调用父类的同步方法" class="headerlink" title="3. 子类是否可以调用父类的同步方法"></a>3. 子类是否可以调用父类的同步方法</h4><p>可以，synchronized 是可重入锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m start "</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"m end "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TT tt = <span class="keyword">new</span> TT();<span class="comment">//new一个子类对象，就先new一个父类对象，锁对象是子类对象</span></span><br><span class="line">        tt.m();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TT</span> <span class="keyword">extends</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" child m start "</span>);</span><br><span class="line">        <span class="keyword">super</span>.m();</span><br><span class="line">        System.out.println(<span class="string">" child m end "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//child m start</span></span><br><span class="line"><span class="comment">////m start</span></span><br><span class="line"><span class="comment">////m end</span></span><br><span class="line"><span class="comment">////child m end</span></span><br></pre></td></tr></table></figure>

<h4 id="4-被锁对象的属性或引用的改变"><a href="#4-被锁对象的属性或引用的改变" class="headerlink" title="4. 被锁对象的属性或引用的改变"></a>4. 被锁对象的属性或引用的改变</h4><ol>
<li>如果锁定对象的属性的值发生变化，不影响锁的使用</li>
<li>如果锁定对象的引用发生变化，同步机制失效，多个线程可以同时访问变量<ol>
<li>锁的是堆内存中的对象，而不是栈内存中的对象的引用，所以new一个新对象后，锁引用就变了</li>
<li>所以锁对象通常要设置为 final类型，保证引用不可以变</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> String nochange;</span><br><span class="line">    <span class="keyword">private</span> String change=<span class="string">""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为加锁的是整个while循环，所以线程1会一直运行下去，锁不会被释放，所以线程2不能取得锁</span></span><br><span class="line">        <span class="comment">//当改变锁引用后，这是线程2可以申请到锁，所以可以打印</span></span><br><span class="line">        <span class="comment">//并且两个线程都有对应的两把锁，因为有两个new出来的队内存对象？</span></span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">new</span> Thread(t::m, <span class="string">"线程1"</span>).start();</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(t::m, <span class="string">"线程2"</span>);</span><br><span class="line">        t.setNochange(<span class="string">"对象的引用不改变"</span>)<span class="comment">//用set不会改变</span></span><br><span class="line">        t.change=<span class="string">"引用改变"</span>;<span class="comment">//指向一个新的对象的引用</span></span><br><span class="line">        t.o = <span class="keyword">new</span> Object(); <span class="comment">// 改变锁引用, 线程2也有机会运行，否则一直都是线程1 运行，因为锁一致被线程1占用</span></span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>注意：==不要以字符串常量作为锁定对象==</li>
</ol>
<p>在下面的例子中， m1和m2其实是锁定的同一对象，这种情况下，还会可能与其他类库发生死锁，比如某类库中也锁定了字符串 “Hello”，但是无法确认源码的具体位置，所以两个 “Hello” 将会造成死锁，因为你的程序和你用的类库无意间使用了同意把锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String s1 = <span class="string">"Hello"</span>;</span><br><span class="line">    String s2 = <span class="string">"Hello"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (s1) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (s2) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常时释放锁"><a href="#异常时释放锁" class="headerlink" title="异常时释放锁"></a>异常时释放锁</h3><p>synchronized锁在发生异常后会==主动释放锁==，并且发生异常时要小心处理同步业务员逻辑中的异常，不然可能发生数据不一致的情况。异常处理用==try-catch捕获处理==</p>
<p>eg：在一个web app处理过程中，多个servlet线程共同访问同一资源，这时如果异常处理不合适，第一个线程抛出异常，其他线程就会进入同步代码区，有可能访问到异常产生的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" start"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count="</span> + count);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">5</span>) &#123;  <span class="comment">// 当count == 5 时，synchronized代码块会抛出异常</span></span><br><span class="line">                               <span class="comment">// 要想正常运行，用try-catch捕获处理异常</span></span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.m();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">"t1"</span>).start(); <span class="comment">// 执行到第5秒时，抛出 ArithmeticException </span></span><br><span class="line">        <span class="comment">// 如果抛出异常后，t2 会继续执行，就代表t2拿到了锁，即t1在抛出异常后释放了锁</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//	  t1 start</span></span><br><span class="line"><span class="comment">//    t1 count=1</span></span><br><span class="line"><span class="comment">//    t1 count=2</span></span><br><span class="line"><span class="comment">//    t1 count=3</span></span><br><span class="line"><span class="comment">//    t1 count=4</span></span><br><span class="line"><span class="comment">//    t1 count=5</span></span><br><span class="line"><span class="comment">//    t2 start</span></span><br><span class="line"><span class="comment">//    t2 count=6</span></span><br><span class="line"><span class="comment">//    Exception in thread "t1" java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">//        at mashibing.c_011.T.m(T.java:30)</span></span><br><span class="line"><span class="comment">//        at mashibing.c_011.T$1.run(T.java:40)</span></span><br><span class="line"><span class="comment">//        at java.lang.Thread.run(Thread.java:748)</span></span><br><span class="line"><span class="comment">//    t2 count=7</span></span><br><span class="line"><span class="comment">//    t2 count=8</span></span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>同步代码块中的语句越少越好, 采用==细粒度==的锁，可以使线程争用时间变短，从而提高效率</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 业务逻辑中，只有下面这句代码需要 sync， 这时不应该给整个方法上锁</span></span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//改进： </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 业务逻辑中，只有下面这句需要 sync，这时不应该给整个方法上锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><p>前提：由于线程在工作时会将共享变量复制到自己的工作空间，从而使得在CPU忙碌时，线程对共享变量副本的修改没有及时写会到主内存中，导致共享变量的数据不一致。</p>
<p>作用：确保将变量的更新操作通知到其他线程，保证共享变量数据一致</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*volatile*/</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;   <span class="comment">// 对比有无volatile的情况下，整个程序运行结果的区别</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" m start "</span>);</span><br><span class="line">        <span class="keyword">while</span> (running) &#123; <span class="comment">// 直到主线程将running设置为false，T线程才会退出</span></span><br><span class="line">            <span class="comment">// 在while中加入一些语句，可见性问题可能就会消失</span></span><br><span class="line">            <span class="comment">//因为加入语句后，CPU可能就会出现空闲，然后就会将共享变量副本同步到到主内存</span></span><br><span class="line">            <span class="comment">//所以，可见性问题可能会消失</span></span><br><span class="line">            <span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">                TimeUnit.MILLISECONDS.sleep(10);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">" m end "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">new</span> Thread(t::m, <span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t.running = <span class="keyword">true</span>;<span class="comment">//主线程设置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>无volatile：上面的代码中，running 是位于堆内存中的t对象的，当线程t1开始运行的时候，CPU会把running值从内存中读到t1线程的工作区，在运行过程中直接使用这个copy；由于CPU繁忙，并不会每次都会将共享变量副本写回到主内存中，这样，当主线程修改running的值之后，t1线程感知不到，所以不会停止运行</p>
</li>
<li><p>使用volatile，当线程修改running值后，会通知所有线程值改变了，要重新读，所以会强制所有线程都去堆内存中读取running的值，这样t线程就会停止运行</p>
</li>
</ul>
<h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><ul>
<li>有序性、可见性</li>
</ul>
<h4 id="对比synchronized"><a href="#对比synchronized" class="headerlink" title="对比synchronized"></a>对比synchronized</h4><ul>
<li>volatile只能保证可见性，不能保证原子性，所以volatile不能替代synchronized</li>
<li>synchronized既保证可见性，也保证原子性</li>
<li>volatile比synchronized效率高</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*AtomicInteger count = new AtomicInteger(0);*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">/*count.incrementAndGet();*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个10个线程的list，执行任务皆是 m方法</span></span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(t::m, <span class="string">"t-"</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动这10个线程</span></span><br><span class="line">        threads.forEach(Thread::start);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// join 到主线程，防止主线程先行结束</span></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 10个线程，每个线程执行10000次，结果应为 100000</span></span><br><span class="line">        System.out.println(t.count);  <span class="comment">// 所得结果并不为 100000，说明volatile 不保证原子性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解决方案：</span></span><br><span class="line"><span class="comment">1. 在方法上加上synchronized即可，synchronized既保证可见性，又保证原子性</span></span><br><span class="line"><span class="comment">2. 使用AtomicInteger代替int（AtomicXXX 代表此类中的所有方法都是原子操作，并且可以保证可见性）</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock 可以完成 synchronized 的任何功能，ReentrantLock比 synchronized 更灵活，主要体现在如下几个方面：</p>
<ol>
<li>ReentrantLock是手动锁，异常后不会释放锁，synchronized异常时jvm会自动释放锁</li>
<li>tryLock 尝试锁定，非阻塞锁，可以设置等待时间</li>
<li>lockInterruptibly 可以中断等待</li>
<li>可以设置公平锁</li>
</ol>
<h3 id="手动锁"><a href="#手动锁" class="headerlink" title="手动锁"></a>手动锁</h3><ul>
<li><p>ReentrantLock是==手动锁，异常后不会释放锁==，必须要手动释放锁，一般在<strong>finally中释放锁</strong></p>
</li>
<li><p>synchronized异常时jvm会自动释放锁</p>
</li>
<li><p>ReentrantLock是手动锁，异常后不会释放锁，必须要手动释放锁，一般在finally中释放锁</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Lock*/</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 相当于 synchronized</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 使用完毕后，必须手动释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"m2..."</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock2 r1 = <span class="keyword">new</span> ReentrantLock2();</span><br><span class="line">        <span class="keyword">new</span> Thread(r1::m1, <span class="string">"t1"</span>).start(); <span class="comment">// m1 已经执行，被t1占有锁this</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(r1::m2, <span class="string">"t2"</span>).start(); <span class="comment">// 锁已经被其他线程占用，m1执行完毕前，不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可”尝试锁定“"><a href="#可”尝试锁定“" class="headerlink" title="可”尝试锁定“"></a>可”尝试锁定“</h3><p>ReentrantLock 可使用==tryLock尝试锁定==， 这样无法锁定、或者在指定时间内无法锁定，线程可以决定是否继续等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock(); </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尝试获取锁，返回true拿到了</span></span><br><span class="line">        <span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">            <span class="comment">// lock.tryLock(5, TimeUnit.SECONDS) // 等5s内还没拿到就返回false</span></span><br><span class="line">            System.out.println(<span class="string">"m2..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">" m2 没拿到锁"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();<span class="comment">//加个是否拥有锁的判断，没有锁释放锁会发生异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock3 r1 = <span class="keyword">new</span> ReentrantLock3();</span><br><span class="line">        <span class="keyword">new</span> Thread(r1::m1, <span class="string">"t1"</span>).start(); <span class="comment">// m1 已经执行，被t1占有锁this</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(r1::m2, <span class="string">"t2"</span>).start(); <span class="comment">// 锁已经被其他线程占用，m1执行完毕后，不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可打断等待"><a href="#可打断等待" class="headerlink" title="可打断等待"></a>可打断等待</h3><p>在一个线程等待锁的过程中，==线程可以被interrupt方法打断等待==，ReentrantLock 可以调用 ==lockInterruptibly==方法判断是否被打断，对线程interrupt方法做出响应。</p>
<p><strong>lockInterruptibly方法作用：</strong><br>1）如果当前线程未被中断且锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。  </p>
<p>2）如果锁被另一个线程保持，则出于线程调度目的，禁用当前线程，并且在发生以下两种情况之一以<br>前，该线程将一直处于休眠状态：<br>     1）锁由当前线程获得；或者 </p>
<pre><code>2）其他某个线程中断当前线程。 </code></pre><p>3）如果当前线程获得该锁，则将锁保持计数设置为 1，并且该方法立即返回。<br>   如果当前线程：<br>       1）在进入此方法时已经设置了该线程的中断状态；或者 </p>
<pre><code>2）在等待获取锁的同时被中断。 </code></pre><p>   则抛出 InterruptedException，并且清除当前线程的已中断状态。 </p>
<p>6）因为此方法是一个显式中断点，所以要优先考虑响应中断，而不是响应锁的普通获取或重入获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock4</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"t1 start"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);  <span class="comment">// 线程一直占用锁</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();<span class="comment">//不可响应中断</span></span><br><span class="line">                lock.lockInterruptibly(); <span class="comment">// t2 尝试获取锁，可响应中断</span></span><br><span class="line">                System.out.println(<span class="string">"t2 start"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"t2 等待中被打断"</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//要进行判断是否拥有锁</span></span><br><span class="line">                lock.unlock(); <span class="comment">// 没有锁定进行unlock就会抛出 IllegalMonitorStateException </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//因为线程2一直在等待，如果不想让线程2等待，想中断它，</span></span><br><span class="line">        <span class="comment">// 那么让主线程打断2的等待，结束掉线程2</span></span><br><span class="line">        t2.interrupt();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可指定公平锁"><a href="#可指定公平锁" class="headerlink" title="可指定公平锁"></a>可指定公平锁</h3><ul>
<li>公平锁：等待时间最长的线程优先获得锁，效率较低</li>
<li>不公平锁：无论先后，线程调度器将会随机给某个线程锁，不用计算线程时序，效率较高</li>
</ul>
<p>ReentrantLock 可以指定为公平锁，效率比较低；</p>
<p>==synchronized 是不公平锁（竞争锁）==，效率比较高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock5</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//fair为false时，为不公平锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);<span class="comment">// 指定锁为公平锁</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"获取锁"</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock(); <span class="comment">// 公平锁 t1 unlock 后，等待时间长的一定是 t2 所以下次一定是 t2 执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock5 t1 = <span class="keyword">new</span> ReentrantLock5();</span><br><span class="line">        ReentrantLock5 t2 = <span class="keyword">new</span> ReentrantLock5();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ThreadLocal-线程局部变量"><a href="#ThreadLocal-线程局部变量" class="headerlink" title="ThreadLocal 线程局部变量"></a>ThreadLocal 线程局部变量</h2><p>ThreadLocal：适合用在需要线程内部自己维护，而不需要其他线程共同维护的共享变量的场景。当线程终止后，这些值会作为垃圾回收。</p>
<ul>
<li>ThreadLocal：使用空间换时间，将变量读到线程中  效率更高</li>
<li>线程同步：使用时间换空间，多个线程同时访问变量</li>
<li>ThreadLocal可能会导致内存泄漏</li>
</ul>
<p>ThreadLocal用set放入局部变量，用get取，用remove删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;Person&gt; p = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(p.get()); <span class="comment">// 2. 虽然threadLocal时共享变量，但是取不到其他线程放入的值，所以此处为null</span></span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            p.set(<span class="keyword">new</span> Person()); <span class="comment">// 1. 往线程局部变量set放入一个person</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">"zhangsan"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Singleton-单例模式"><a href="#Singleton-单例模式" class="headerlink" title="Singleton 单例模式"></a>Singleton 单例模式</h2><p>单例模式：<strong>系统中对于某类的只能有一个对象</strong>，如servlet就是单例多线程模式</p>
<p>单例模式的线程安全可以参考这篇博文：<a href="https://www.cnblogs.com/xudong-bupt/p/3433643.html" target="_blank" rel="noopener">设计模式之单例模式(线程安全)</a>，除了博文里介绍的实现三种方法外，还有第四种方法：采用==静态内部类==这种方式，==既不用加锁，也能实现懒加载==（只有当用到类的时候才开始加载）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton s = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><p>解决并发情况下的容器线程安全问题的，给多线程环境准备一个线程安全的容器对象。</p>
<h2 id="Map-Set"><a href="#Map-Set" class="headerlink" title="Map/Set"></a>Map/Set</h2><h3 id="无并发"><a href="#无并发" class="headerlink" title="无并发"></a>无并发</h3><ul>
<li><p>HashMap：基于哈希算法的==无序==key-value集合</p>
</li>
<li><p>LinkedHashMap：按照插入顺序或访问顺序进行排序的==有序==HashMap</p>
</li>
<li><p>TreeMap：基于==红黑树==的key-value集合，所以是==排序==好的map  </p>
</li>
</ul>
<p><u><strong>有序的插入时效率低 ，但读取效率高</strong></u></p>
<h3 id="加锁低并发"><a href="#加锁低并发" class="headerlink" title="加锁低并发"></a>加锁低并发</h3><ul>
<li>HashTable：每次加锁，都锁一个map对象，所以每次只有一个线程访问这个map对象       </li>
<li>Collections.synchronizedMap() ：将没有锁的map对象的变为加了锁的map</li>
</ul>
<h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><ul>
<li><p>ConcurrentHashMap - 并发高</p>
<p>加的是分段锁，将map容器分为16段，每段都有一个锁 segment，所以每次可以有多个线程同时访问者map容器中的一段数据，增加了并发性; <em>1.8以后 使用 Node + synchronized+CAS</em></p>
</li>
<li><p>ConcurrentSkipListMap </p>
<p>要求==高并发且排序==的情况时使用，插入效率较低，但是读取很快</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * skipMap: https://blog.csdn.net/sunxianghuang/article/details/52221913</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_ConcurrentMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); </span></span><br><span class="line">        <span class="comment">//Map&lt;String, String&gt; map = new Hashtable&lt;&gt;(); </span></span><br><span class="line">        <span class="comment">//Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); </span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;();  </span><br><span class="line">    </span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        Thread[] ths = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// 启动了一个门闩，每有一个线程退出，门闩就减1，直到所有线程结束，门闩打开，主线程结束</span></span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(ths.length); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 创建100个线程，每个线程添加10000个元素到map，并启动这些线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ths.length; i++) &#123;</span><br><span class="line">            ths[i] = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    map.put(<span class="string">"a"</span> + r.nextInt(<span class="number">10000</span>), <span class="string">"a"</span> + r.nextInt(<span class="number">100000</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;, <span class="string">"t"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.asList(ths).forEach(Thread::start);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();<span class="comment">//利用门闩让主线程等</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><strong>队列存取的几个方法：</strong></p>
<p>add与remove对应：队列满则抛出异常</p>
<p>offer与poll对应：不阻塞，队列满则返回false</p>
<p>put与take对应：阻塞，队满则等待</p>
<h3 id="无并发-1"><a href="#无并发-1" class="headerlink" title="无并发"></a>无并发</h3><p>ArrayList（无序）、LinkedList（有序）    </p>
<h3 id="低并发"><a href="#低并发" class="headerlink" title="低并发"></a>低并发</h3><ol>
<li>Collections.synchronizedList()：将普通集合List变为同步集合的工具方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T03_SynchronizedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 返回的实例，每个方法都加了一个互斥锁</span></span><br><span class="line">        List&lt;String&gt; syncList = Collections.synchronizedList(list);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>Vector   </p>
</li>
<li><p><strong>写时复制List：CopyOnWriteList</strong>  </p>
<p>原理：当发生写操作(添加、删除、修改)时，容器就会复制原有容器一份然后对新操作进行写操作，然后再将引用转向新的容器</p>
<p>好处：保证读操作不需要锁也能正常访问，是一种读写分离的实现方式</p>
<p>缺点：写的效率极低，特定场景下才会使用到，如事件监听器</p>
<p>==适用于写少读多==</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_CopyOnWriteList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list =</span><br><span class="line">                <span class="comment">//new ArrayList&lt;&gt;();//并发会出问题</span></span><br><span class="line">                <span class="comment">//new Vector&lt;&gt;(); //并发没有问题，但是效率低</span></span><br><span class="line">                <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();  <span class="comment">// 写速极慢，读取快</span></span><br><span class="line"></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        Thread[] ths = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ths.length; i++) &#123;</span><br><span class="line">            Runnable task = () -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    list.add(<span class="string">"a"</span> + r.nextInt(<span class="number">100</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            ths[i] = <span class="keyword">new</span> Thread(task);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        runAndComputeTime(ths);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAndComputeTime</span><span class="params">(Thread[] ths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Arrays.asList(ths).forEach(Thread::start);</span><br><span class="line">        Arrays.asList(ths).forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高并发-1"><a href="#高并发-1" class="headerlink" title="高并发"></a>高并发</h3><h4 id="非阻塞同步队列"><a href="#非阻塞同步队列" class="headerlink" title="非阻塞同步队列"></a>非阻塞同步队列</h4><h5 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h5><p>基于链接节点的==无界==线程安全队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_ConcurrentQueue</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            queue.offer(<span class="string">"a"</span> + i); </span><br><span class="line">            <span class="comment">// 有返回值，返回false代表没有加入成功，true 代表成功，并且此方法不会阻塞</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        System.out.println(queue.size());</span><br><span class="line"></span><br><span class="line">        System.out.println(queue.poll()); <span class="comment">// 取出队头</span></span><br><span class="line">        System.out.println(queue.size());</span><br><span class="line"></span><br><span class="line">        System.out.println(queue.peek()); <span class="comment">// 取出队头，但是不删除队头</span></span><br><span class="line">        System.out.println(queue.size());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 双端队列 Deque 发音： dai ke</span></span><br><span class="line">        <span class="comment">//Deque&lt;String&gt; deque = new ConcurrentLinkedDeque&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//deque.addFirst();</span></span><br><span class="line">        <span class="comment">//deque.addLast();</span></span><br><span class="line">        <span class="comment">//deque.pollFirst();</span></span><br><span class="line">        <span class="comment">//deque.pollLast();</span></span><br><span class="line">        <span class="comment">//deque.peekFirst();</span></span><br><span class="line">        <span class="comment">//deque.peekLast();</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="阻塞同步队列BlockQueue"><a href="#阻塞同步队列BlockQueue" class="headerlink" title="阻塞同步队列BlockQueue"></a>阻塞同步队列BlockQueue</h4><h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h5><p>阻塞==无界==同步队列，直到内存满了才会停止生产：put（生产，添加）和take（消费，拿出）对应</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成生产者消费者模式</span></span><br><span class="line"><span class="comment"> * 使用场景较多。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T05_LinkedBlockingQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">// 启动生产者线程生产</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(<span class="string">"aaa"</span> + j); <span class="comment">// put 方法，给容器添加元素，如果容器满了，则会阻塞等待</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"p"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启用消费者线程消费</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + queue.take()); <span class="comment">// 从队列中拿数据，如果空了，则会阻塞等待</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"c"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><p>阻塞==有界==同步队列：offer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T06_ArrayBlockingQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);<span class="comment">//容量为10个</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            queue.put(<span class="string">"a"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//queue.put("a11"); // 满了继续装会阻塞等待消费者消费</span></span><br><span class="line">        <span class="comment">//queue.add("a11"); // 满了继续装会抛出异常</span></span><br><span class="line">        <span class="comment">//System.out.println(queue.offer("a11")); // 满了继续装会返回false，不会将all加进去</span></span><br><span class="line">        System.out.println(queue.offer(<span class="string">"a11"</span>, <span class="number">1</span>, TimeUnit.SECONDS)); <span class="comment">// 会等待1s,返回false, 如果1s内有空闲,则添加成功后返回true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>LinkedBlockingQueue与ArrayBlockingQueue的区别</strong></p>
<ol>
<li><p>LinkedBlockingQueue是基于链表实现，ArrayBlockingQueue基于数组实现（FIFO）</p>
</li>
<li><p>LinkedBlockingQueue因为是链表，所以是无界的；而ArrayBlockingQueue创建时就指定了容量（LinkedBlockingQueue创建时，默认会直接创建一个Integer.MAX_VALUE的数组，当插入少，读取多时，就会造成很大的空间浪费。而LinkedBlockingQueue实际上实在等需要的时候才会创建一个Node节点。）</p>
</li>
<li><p>LinkedBlockingQueue内部读写各有一个锁，ArrayBlockingQueue读写共享一个锁</p>
</li>
<li><p>大多数场景适合使用LinkedBlockingQueue。在JDK源码当中有说明，LinkedBlockingQueue比ArrayBlockingQueue有更高的吞吐量，但是性能表现更难预测（也就是说相比ArrayBlockingQueue性能表现不稳定，但是也很稳定了）。</p>
<p>为什么会有吞吐量的区别，个人以为可能是ArrayBlockingQueue两个锁的缘故，在大量并发的情况下，插入和读取都很多时，就会造成一点的时间浪费。</p>
</li>
</ol>
<h5 id="TransferQueue"><a href="#TransferQueue" class="headerlink" title="TransferQueue"></a>TransferQueue</h5><p>原理：拥有transfer方法，传输，当transfer一个元素时，如果有take方法阻塞等待获取元素，则不向队列中保存，直接给等待的take方法</p>
<ul>
<li>情景：如果将元素放入队列，再拿给消费者线程，太慢了，如果需要的效率更高，可以使用TransferQueue来解决更高的并发</li>
<li>消费者线程先启动等待商品，生产者生产东西后直接交给消费者消费，不放进容器中，如果没有消费者等待消费，则会发生阻塞</li>
<li>put add 都不会阻塞，会直接添加到容器中，只有transfer才有此种等待消费者直接获取的功能，所以==transfer是有容量的==</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T08_TransferQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        TransferQueue mq = <span class="keyword">new</span> LinkedTransferQueue();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先让消费者线程等待</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(mq.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再让生产者线程生产</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mq.transfer(<span class="string">"aaa"</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果后让消费者启动则会报错</span></span><br><span class="line">        <span class="comment">/*new Thread(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(mq.take());</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;).start();*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h5><p>一种特殊的TransferQueue，==容量为0==</p>
<p>区别：TransferQueue是有容量的，可以通过add/put等方法向队列中加入元素；但是SynchronousQueue是没有的，所以生产的东西只能<strong>直接交给消费者消费，不能放在容器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T09_SynchronousQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        BlockingQueue queue = <span class="keyword">new</span> SynchronousQueue();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(queue.take()); <span class="comment">// 取不到就阻塞</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//queue.add("aaa"); // IllegalStateException: Queue full  抛出异常，因为没有容量</span></span><br><span class="line">        queue.put(<span class="string">"aaa"</span>);  <span class="comment">// 会阻塞等待消费者线程获取,内部是transfer</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(queue.size()); <span class="comment">// 长度为0 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h4><h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h5><p>出队有个时间限制, 每个元素有一个等待时间, 可以<strong>按照等待时间排序元素</strong>，DelayQueue元素必须为 ==Delayed类型==的,即<strong>必须设置元素的等待时间</strong></p>
<p>用途：<strong>定时执行任务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T07_DelayQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> runningTime;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">long</span> runTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.runningTime = runTime;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这是每个元素的等待时间, 越是后加入的元素,时间等待的越长</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> unit.convert(runningTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这是排序规律, 执行等待时间最短的排在前面</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) (o.getDelay(TimeUnit.MILLISECONDS) - <span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> runningTime + <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        MyTask myTask1 = <span class="keyword">new</span> MyTask(timestamp + <span class="number">1000</span>); <span class="comment">// 1s后执行</span></span><br><span class="line">        MyTask myTask2 = <span class="keyword">new</span> MyTask(timestamp + <span class="number">2000</span>);</span><br><span class="line">        MyTask myTask3 = <span class="keyword">new</span> MyTask(timestamp + <span class="number">1500</span>);</span><br><span class="line">        MyTask myTask4 = <span class="keyword">new</span> MyTask(timestamp + <span class="number">2500</span>);</span><br><span class="line">        MyTask myTask5 = <span class="keyword">new</span> MyTask(timestamp + <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        DelayQueue&lt;MyTask&gt; tasks = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line">        tasks.put(myTask1);</span><br><span class="line">        tasks.put(myTask2);</span><br><span class="line">        tasks.put(myTask3);</span><br><span class="line">        tasks.put(myTask4);</span><br><span class="line">        tasks.put(myTask5);</span><br><span class="line"></span><br><span class="line">        System.out.println(tasks);  <span class="comment">// 确实按照我们排的顺序执行的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.size(); i++) &#123;</span><br><span class="line">            System.out.println(tasks.take());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>作用：提高并行计算效率</p>
<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><ul>
<li>Executor只有一个execute接口，==用于执行任务==，可以<strong>传入一个Runnable接口</strong></li>
<li><strong>runnable接口</strong>用于==定义一项任务==, 将任务传递给Executor后, 由 Executor.execute() 方法定义如何执行任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_MyExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> T01_MyExecutor().execute(()-&gt; System.out.println(<span class="string">"hello executor"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        command.run();<span class="comment">//方法调用</span></span><br><span class="line">        <span class="comment">// new Thread(command).star(); //创建一个线程执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><p>ExecutorService是Executor的服务, service 一般都是后台线程, 启动后一直在后台运行,等待任务抛入，然后将任务扔到容器中执行.</p>
<h4 id="字段含义"><a href="#字段含义" class="headerlink" title="字段含义"></a>字段含义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">System.out.println(service); </span><br><span class="line"><span class="comment">//[Running, pool size = 5, active threads = 5, queued tasks = 1, completed tasks = 0]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>pool size =  5  线程池的容量</li>
<li>active thread = 5 激活的线程队列长度</li>
<li>queued tasks = 1 等待处理任务长度</li>
<li>completed task = 0 完成执行的任务数量     </li>
</ul>
<p><strong>与Executor的区别：</strong></p>
<ol>
<li>没有本质区别,只不过execute只能执行Runnable任务，ExecutorService还可执行Callable任</li>
<li>ExecutorService除了execute外还有submit可以扔任务</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_MyExecutorService</span>  </span>&#123;</span><br><span class="line">    ExecutorService executorService = <span class="keyword">null</span>;</span><br><span class="line">    Callable callable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h4><p>与类似Runnable，又有所区别：</p>
<ol>
<li>执行Runnable任务时,实际调用的是run方法；执行Callable任务时,实际调用的是 call方法 </li>
<li>callable 有返回值，Runnable没有返回值；如果线程运行结束后需要返回值,则需要callable </li>
<li>callable可以抛出异常,而Runnable不能抛出异常,必须自己处理</li>
</ol>
<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>未来的执行结果，在ExecutorService中，submit方法返回的是一个Future类型</p>
<ul>
<li>Future submit(Runnable): 提交Runnable任务以执行并返回表示该任务的Future</li>
<li>Future submit(Callable): 提交一个有返回值的callable任务,并将返回值作为future对象包装返回</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T06_Future</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未来的一个callable任务(因为有返回值)</span></span><br><span class="line">        <span class="comment">//因为FutureTask指定一个Integer泛型类，所以返回的100</span></span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//创建一个新的线程执行任务</span></span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(task.get()); <span class="comment">// 阻塞等待任务执行完成, 获取到返回值</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//********************************</span></span><br><span class="line">        <span class="comment">// 使用ExecutorService的submit替代FutureTask</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        Future&lt;Integer&gt; result = service.submit(() -&gt; &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(result.isDone()); <span class="comment">// false 执行未完毕</span></span><br><span class="line">        System.out.println(result.get()); <span class="comment">// 1 </span></span><br><span class="line">        System.out.println(result.isDone()); <span class="comment">// true  执行已完毕</span></span><br><span class="line">        System.out.println(result.get()); <span class="comment">// 一直等待</span></span><br><span class="line">        System.out.println(service.shutdownNow()); <span class="comment">// 立即等待</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>是一个用于操作上面对象的工具类和工厂类</p>
<h3 id="ThreadPool-线程池"><a href="#ThreadPool-线程池" class="headerlink" title="ThreadPool 线程池"></a>ThreadPool 线程池</h3><ul>
<li>线程启动和关闭要消耗资源，所以线程池省资源，不用每次都创建一个新的线程执行一个任务,而是线程池中有线程可以执行任务，有任务来线程就去执行，即用老线程去处理任务；线程池相当于工厂的工人，等待任务</li>
<li>每个线程都有自己的任务队列，等待去执行</li>
</ul>
<ul>
<li><p>线程池中维护了两个任务队列：未执行的任务队列、已执行的任务队列</p>
</li>
<li><p>线程池的几个状态：Running、Shutting down、Terminated</p>
</li>
</ul>
<p>ExecutorService的几个方法可以用来判断线程池状态：</p>
<ol>
<li>shutdown()：未执行完毕就不会停止运行,只会进入正在停止中的状态，running状态返回false</li>
<li>service.isTerminated()：判断所有任务是否执行完毕，除了terminated外的状态都返回false</li>
<li>isShutdown()：判断是否在停止中，shutting down状态返回true   </li>
</ol>
<p>==主要的线程池： FixedThreadPool、CachedThreadPool、SingleThreadExecutor、ScheduledThreadPool、WorkStealingPool、ForkJoinPool==</p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>线程池的实现原理，除了ForkJoinPool与WorkStealingPool线程池，其他线程池大部分线程池背后都是ThreadPoolExecutor。创建对象时字段的含义如下：</p>
<ul>
<li>corePoolSize：线程池核心线程数，最小线程数</li>
<li>maxnumPoolSize：最大线程数</li>
<li>keepAlive：线程空闲后存活时间， 0代表永远不会消失</li>
<li>timeUnit ：上面存活时间的单位  </li>
<li>第四个参数 ：==并发容器== （注意每个线程池所用到的并发容器！！）</li>
</ul>
<h3 id="基于ThreadPoolExecutor创建的线程池"><a href="#基于ThreadPoolExecutor创建的线程池" class="headerlink" title="基于ThreadPoolExecutor创建的线程池"></a>基于ThreadPoolExecutor创建的线程池</h3><h4 id="1-FixedThreadPool-固定容量线程池"><a href="#1-FixedThreadPool-固定容量线程池" class="headerlink" title="1. FixedThreadPool 固定容量线程池"></a>1. FixedThreadPool 固定容量线程池</h4><p><img src="../../../%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563971383401.png" alt="1563971383401"></p>
<p><img src="../../../%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563970723658.png" alt="1563970723658"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T05_ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">// 产生固定长度的线程池，一般线程池是用executorService接受</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123; <span class="comment">// 执行六个任务,  在只有五个固定容量的线程池中</span></span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(service); <span class="comment">// [Running, pool size = 5, active threads = 5, queued tasks = 1, completed tasks = 0]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        service.shutdown(); <span class="comment">// 未执行完毕,不会停止,只会进入停止中状态</span></span><br><span class="line">        System.out.println(service.isTerminated()); <span class="comment">// false 判断所有任务是否执行完毕</span></span><br><span class="line">        System.out.println(service.isShutdown()); <span class="comment">// true 状态是否在关闭过程中，还没关闭完</span></span><br><span class="line">        System.out.println(service);  <span class="comment">//ThreadPoolExecutor[Shutting down, pool size = 5, active threads = 5, queued tasks = 1, completed tasks = 0]</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>); <span class="comment">// 5s 后肯定执行完成了</span></span><br><span class="line"></span><br><span class="line">        System.out.println(service.isTerminated()); <span class="comment">// true </span></span><br><span class="line">        System.out.println(service.isShutdown()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(service); <span class="comment">// ThreadPoolExecutor[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 6]      </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-CachedThreadPool-可缓存的线程池"><a href="#2-CachedThreadPool-可缓存的线程池" class="headerlink" title="2. CachedThreadPool 可缓存的线程池"></a>2. CachedThreadPool 可缓存的线程池</h4><p><img src="../../../%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563970766396.png" alt="1563970766396"></p>
<p>工作原理：</p>
<ol>
<li>当有请求进入线程池内, 线程池将会启用一个线程；当再次有个请求进入线程池内, 并且上个线程未结束, 仍然会启用一个线程</li>
<li>当有线程执行完毕后,这个线程不会被清除, 而是等待任务,当有请求进入时, 直接使用缓存线程调用</li>
<li>当线程一直不被使用, 缓存最多持续1分钟(AliveTime默认值),就会被线程池销毁</li>
</ol>
<p>跟 fixedThreadPool 类似, 只不过没有上限的线程数(根据CPU所能开启的线程数，最多Integer最大值), 是一种弹性操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T08_CachedThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// pool size 为0</span></span><br><span class="line">        System.out.println(service); <span class="comment">// java.util.concurrent.ThreadPoolExecutor@7f31245a[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0]cu'</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pool size 变为2 </span></span><br><span class="line">        System.out.println(service); <span class="comment">// java.util.concurrent.ThreadPoolExecutor@7f31245a[Running, pool size = 2, active threads = 2, queued tasks = 0, completed tasks = 0]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">80</span>); <span class="comment">// 最多持续1分钟,这里sleep80s</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pool size 变为0</span></span><br><span class="line">        System.out.println(service); <span class="comment">// java.util.concurrent.ThreadPoolExecutor@7f31245a[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 2]</span></span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-SingleThreadExecutor-单线程执行器"><a href="#3-SingleThreadExecutor-单线程执行器" class="headerlink" title="3. SingleThreadExecutor 单线程执行器"></a>3. SingleThreadExecutor 单线程执行器</h4><p><img src="../../../%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563970797425.png" alt="1563970797425"></p>
<p>线程池中只有一个线程；作用：保证线程执行的==时序性==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T09_SingleThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> j = i;</span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(j + <span class="string">" "</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-ScheduledThreadPool-调度线程池"><a href="#4-ScheduledThreadPool-调度线程池" class="headerlink" title="4. ScheduledThreadPool 调度线程池"></a>4. ScheduledThreadPool 调度线程池</h4><p><img src="../../../%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563971708807.png" alt="1563971708807"></p>
<p><img src="../../../%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563970839943.png" alt="1563970839943"></p>
<p>执行定时的任务线程池,类似Delay, 可以替代Timer，且线程可以复用</p>
<p>scheduleAtFixedRate：使用固定的频率执行某个任务</p>
<p><img src="../../../%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563971897048.png" alt="1563971897048"></p>
<ul>
<li>command: 执行的任务，Runnable类型</li>
<li>initialDelay: 第一次执行延时多久执行</li>
<li>period: 每隔多久执行一次这个任务</li>
<li>unit: 时间单位</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T10_ScheduledPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">        service.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">500</span>, TimeUnit.MILLISECONDS);  </span><br><span class="line">		<span class="comment">//任务：每隔500ms打印一下线程名称</span></span><br><span class="line">		<span class="comment">//延时执行：0秒，即立即执行</span></span><br><span class="line">		<span class="comment">//每隔500ms执行一次任务</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 线程睡1000ms,而每 500 就要执行一个任务</span></span><br><span class="line">        <span class="comment">// 上个线程未执行完毕,会启用新的线程执行</span></span><br><span class="line">        <span class="comment">// 如果线程池已满,只有延时</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于ForkJoinPool创建的线程池"><a href="#基于ForkJoinPool创建的线程池" class="headerlink" title="基于ForkJoinPool创建的线程池"></a>基于ForkJoinPool创建的线程池</h3><h4 id="1-WorkStealingPool-工作窃取线程池"><a href="#1-WorkStealingPool-工作窃取线程池" class="headerlink" title="1. WorkStealingPool 工作窃取线程池"></a>1. WorkStealingPool 工作窃取线程池</h4><p><img src="../../../%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563970981753.png" alt="1563970981753"></p>
<p>工作窃取线程池：假设共有三个线程同时执行, A, B, C；当A,B线程池尚未处理任务结束,而C已经处理完毕,则C线程会从A或者B的任务队列中中窃取任务执行,这就叫工作窃取</p>
<ul>
<li>WorkStealingPool 是基于 ForkJoinPool实现的</li>
<li>work stealing 的线程全是deamon线程,即后台线程,精灵线程,守护线程</li>
</ul>
<p>deamon线程：只要虚拟机不停止，线程就不停止，一直在等待执行任务；可以通过对主线程阻塞解决</p>
<ul>
<li>workStealingPool 根据cpu核数自动启动多少个线程去执行任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T11_WorkStealingPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// CPU 核数</span></span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// workStealingPool 根据cpu核数自动启动多少个线程去执行任务</span></span><br><span class="line">        ExecutorService service = Executors.newWorkStealingPool();</span><br><span class="line">        service.execute(<span class="keyword">new</span> R(<span class="number">1000</span>));  <span class="comment">// 我的cpu核数为4 启动5个线程,其中第一个是1s执行完毕,其余都是2s执行完毕,</span></span><br><span class="line">         <span class="comment">// 有一个任务会进行等待,当第一个执行完毕后,会再次偷取第5个任务执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Runtime.getRuntime().availableProcessors(); i++) &#123;</span><br><span class="line">            service.execute(<span class="keyword">new</span> R(<span class="number">2000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">// deamon线程当main方法结束时, 此方法虽然还在后台运行,但是无输出</span></span><br><span class="line">    <span class="comment">// 可以通过对主线程阻塞解决</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">R</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> time;</span><br><span class="line"></span><br><span class="line">        R(<span class="keyword">int</span> time) &#123;</span><br><span class="line">            <span class="keyword">this</span>.time = time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(time);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  "</span> + time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-ForkJoinPool-分治线程池"><a href="#2-ForkJoinPool-分治线程池" class="headerlink" title="2. ForkJoinPool 分治线程池"></a>2. ForkJoinPool 分治线程池</h4><p><img src="../../../%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/assets/1563971266019.png" alt="1563971266019"></p>
<p>“分而治之”的线程池：将一个任务拆分多个任务执行(可以无限切分),然后将结果合并</p>
<ul>
<li>比如大量的并行计算, 如下: 求100_0000个数字之和, 使用多线程</li>
</ul>
<p>ForkJoinPool中执行的任务一定是ForkJoinTask任务，可以用RecursiveAction、RecursiveTask两种继承ForkJoinTask的类进行实现，两者的区别：</p>
<ul>
<li><p>RecursiveAction: 递归操作 没有返回值</p>
<ul>
<li>RecursiveTask: 递归操作,有返回值</li>
<li>只有RecursiveTask才有join，join方法可以阻塞；RecursiveAction没有join，只能通过in.read()阻塞</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T12_ForkJoinPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100_0000</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_NUM = <span class="number">5_0000</span>; <span class="comment">// 每个线程最多可以运行5万个数字相加</span></span><br><span class="line">    <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化这100_000个数字, 每个数字范围在100之内</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = random.nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有数字和, 事先计算:</span></span><br><span class="line">        <span class="comment">//System.out.println(Arrays.stream(nums).sum()); // 使用单线程stream api 进行求和</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//无返回值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTask</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line">        </span><br><span class="line">        AddTask(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 进行计算</span></span><br><span class="line">            <span class="comment">// 如果计算的数的和的范围 小于 MAX_NUM, 进行计算,否则进行 fork </span></span><br><span class="line">            <span class="keyword">if</span> (end - start &lt;= MAX_NUM) &#123;</span><br><span class="line">                <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                    sum += nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"sum = "</span> + sum);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> middle = (end - start) / <span class="number">2</span>;</span><br><span class="line">                AddTask subTask1 = <span class="keyword">new</span> AddTask(start, middle);</span><br><span class="line">                AddTask subTask2 = <span class="keyword">new</span> AddTask(middle, end);</span><br><span class="line">                subTask1.fork();</span><br><span class="line">                subTask2.fork();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有返回值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTask2</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line">        </span><br><span class="line">        AddTask2(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (end - start &lt;= MAX_NUM) &#123;</span><br><span class="line">                <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                    sum += nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> middle = start + (end - start) / <span class="number">2</span>; <span class="comment">// 注意这里，如果有问题，会抛出java.lang.NoClassDefFoundError: Could not initialize class java.util.concurrent.locks.AbstractQueuedSynchronizer$Node 异常</span></span><br><span class="line">                AddTask2 subTask1 = <span class="keyword">new</span> AddTask2(start, middle);</span><br><span class="line">                AddTask2 subTask2 = <span class="keyword">new</span> AddTask2(middle, end);</span><br><span class="line">                subTask1.fork();</span><br><span class="line">                subTask2.fork();</span><br><span class="line">                <span class="keyword">return</span> subTask1.join() + subTask2.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ForkJoinPool fjp = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        AddTask2 task = <span class="keyword">new</span> AddTask2(<span class="number">0</span>, nums.length);</span><br><span class="line">        fjp.execute(task);</span><br><span class="line">        System.out.println(task.join());<span class="comment">//join是阻塞的，不需要in.read进行阻塞</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//System.in.read();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h3 id="1-监控元素个数"><a href="#1-监控元素个数" class="headerlink" title="1.监控元素个数"></a>1.监控元素个数</h3><p>实现一个容器，提供两个方法，add，size； 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到达5时，线程2给出提示并结束</p>
<p><strong>a) wait/notify</strong></p>
<p>wait()、notify/notifyAll() 方法是Object的本地final方法，无法被重写；一般配合synchronized 关键字使用</p>
<ul>
<li>wait ：让获取某个对象的锁的线程等待，并且让线程释放当前对象的锁</li>
<li>notify：当另一个线程获得这个对象锁后，可以使用notify方法唤醒在这个对象上等待的线程（具体是哪个线程由CPU调度决定）；因为线程不能自己叫醒自己(暂时不可实现），所以只能让另外一个线程执行notify方法唤醒等待线程</li>
<li>notifyall：叫醒所有正在等待的线程</li>
<li>notify和notifyall唤醒等待线程后==不会立即释放锁==</li>
<li>==wait()与notify() 方法的调用必须在同步代码块中==</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object ele)</span> </span>&#123;</span><br><span class="line">        list.add(ele);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyContainer3 container = <span class="keyword">new</span> MyContainer3();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">		<span class="comment">//启动监控元素个数的线程t2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"t2 启动"</span>);</span><br><span class="line">                <span class="keyword">if</span> (container.size() != <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"监测到容器长度为5，线程2立即退出"</span>);</span><br><span class="line">                <span class="comment">//退出之前又唤醒等待t1线程，让它继续运行</span></span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//启动元素增加的线程t1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    container.add(<span class="keyword">new</span> Object());</span><br><span class="line">                    System.out.println(<span class="string">"add "</span> + i);</span><br><span class="line">                    <span class="comment">// 当长度为5时，通知 t2 进行退出</span></span><br><span class="line">                    <span class="keyword">if</span> (container.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                        lock.notify(); <span class="comment">// notify 不会释放锁，即便通知t2，t2也获取不到锁</span></span><br><span class="line">                        <span class="comment">// 可以在wait一下，将锁释放，再让t2通知t1继续执行</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b) CountDownLatch实现</p>
<p>使用Countdown(往下数)Latch(门闩)替代 wait notify来进行通信：通信简单，同时也可以指定等待时间</p>
<ul>
<li>CountDownLatch中使用await和countDown 方法替代 wait 和 notify</li>
<li>门闩不能保证可见性，不是一种同步方式，只是一种线程通信方式，保证不了可见性</li>
<li>CountDownLatch不涉及锁定，当count值为0时，门闩就会打开，当前线程继续运行</li>
</ul>
<p>所以当不涉及同步，只涉及线程通信的时候，用synchronized + wait + notify 就显得太重了，利用CountDownLatch+volatile替代效率更高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyContainer5 container = <span class="keyword">new</span> MyContainer5();</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"t2 启动"</span>);</span><br><span class="line">            <span class="keyword">if</span> (container.size() != <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    latch.await();</span><br><span class="line">                    <span class="comment">// 指定等待时间</span></span><br><span class="line">                    <span class="comment">//latch.await(5000, TimeUnit.MILLISECONDS);</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"监测到容器长度为5，线程2立即退出"</span>);</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"t1 启动"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                container.add(<span class="keyword">new</span> Object());</span><br><span class="line">                System.out.println(<span class="string">"add "</span> + i);</span><br><span class="line">                <span class="comment">// 当长度为5时，撤掉一个门闩，此时门闩为0，门会打开，即t2会执行</span></span><br><span class="line">                <span class="keyword">if</span> (container.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="comment">//减1，变为0，门闩打开，线程2运行</span></span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-生产者与消费者"><a href="#2-生产者与消费者" class="headerlink" title="2.生产者与消费者"></a>2.生产者与消费者</h3><p>实现方法：</p>
<h4 id="a-wait-notify"><a href="#a-wait-notify" class="headerlink" title="a) wait/notify"></a>a) wait/notify</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer1</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;T&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (MAX == count) &#123; <span class="comment">// 如果容量最大，释放锁等待    </span></span><br><span class="line">            <span class="comment">///【问题1.这里为什么使用while，而不是使用if？？？】</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则 put </span></span><br><span class="line">        list.add(t);</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">this</span>.notifyAll(); <span class="comment">// 通知消费者线程，可以消费了</span></span><br><span class="line">        <span class="comment">// 【问题2.这里为什么调用 notifyAll 而不是 notify ？】</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (list.size() == <span class="number">0</span>) &#123; <span class="comment">// 如果容量为空，释放锁等待  </span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则获取</span></span><br><span class="line">        T t = list.removeFirst();</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">this</span>.notifyAll(); <span class="comment">// 通知生产者线程生产</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【问题1. 为什么使用while 而不是使用 if 】</strong><br>①上述代码中，在容器已满的情况下，put方法会wait等待，当容器中的元素被消费者消费了一部分，就会唤醒所有的生产者线程</p>
<p>②如果用if：生产者线程会在wait后继续向下执行，直接执行list.add(t)，那么多个生产者线程执行list.add() 就有可能出现数据一致性的问题。<br>③如果使用while：则会先循环判断有没有空位生产，再决定要不要list.add(t)，就避免了这些问题。</p>
<p>【<strong>不是有锁吗？为什么会需要循环判断？</strong>】<br>线程wait之后，锁就会失去；线程再次被唤醒时，并且得到锁之后因为没有循环判断，生产者线程就不会判断容器是否有空位放，因而会直接加入到容器中，造成多个线程同时向容器中生产东西。</p>
<p><strong>【问题2. 为什么调用 notifyAll 而不是 notify ？】</strong><br>因为notify有可能再次叫醒一个生产者线程，而不是去唤醒消费者线程</p>
<p>上述方法虽然可以实现生产消费模型，但是notifyall唤醒所有线程的方法效率较低，我们可以使用以下方法进行改进。</p>
<h4 id="b-lock与Condition"><a href="#b-lock与Condition" class="headerlink" title="b) lock与Condition"></a>b) lock与Condition</h4><p>Condition可以替代传统的线程间通信，用await()替代wait，用signal替代notify()，用signalAll()替代notifyAll()。condition可以为==多个线程之间创建不同的condition==，也就是可以==精确唤醒某些线程==</p>
<p>注意：condition()是被绑定到Lock上面的，要创建一个Lock的conditon，需要用newCondition 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">consumer2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;T&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> Max = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition consumer = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition produce = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (Max == count) &#123;</span><br><span class="line">                produce.await();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(t);</span><br><span class="line">            ++count;</span><br><span class="line">            consumer.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                consumer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            t = list.removeFirst();</span><br><span class="line">            --count;</span><br><span class="line">            produce.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        consumer2&lt;String&gt; consumer = <span class="keyword">new</span> consumer2();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">                    System.out.println(consumer.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"consumer"</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"produce"</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-火车票销售"><a href="#3-火车票销售" class="headerlink" title="3. 火车票销售"></a>3. 火车票销售</h3><p>题目：有N张火车票，每张票都有一个编号，同时有10个窗口对外售票，请写一个模拟程序</p>
<ol>
<li>第一个程序：线程同步不安全，导致重复销售，超量销售等问题</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; tickets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//静态方法，类加载时会自动加载</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            tickets.add(<span class="string">"票-"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (tickets.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"销售了："</span> + tickets.remove(<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>第二个程序：使用Vector同步容器替换List容器</p>
<p>依然不能解决问题，判断和操作依然是复合操作，即是分离的，不是原子操作</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Vector&lt;String&gt; tickets = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            tickets.add(<span class="string">"票-"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (tickets.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将问题方法，睡1s</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"销售了："</span> + tickets.remove(<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>第三个程序：使用synchronized，可以解决问题，但是效率不高</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; tickets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            tickets.add(<span class="string">"票-"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (tickets.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// sychronized 保证了原子性，但是效率低</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (tickets) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"销售了："</span> + tickets.remove(<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>第四个程序：使用同步队列，解决问题，效率较好</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ConcurrentLinkedQueue&lt;String&gt; queue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            queue.add(<span class="string">"票-"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    String t = queue.poll(); <span class="comment">// 取出头，拿不到就是空值</span></span><br><span class="line">                    <span class="comment">//就算线程在这里了被另一个线程打断，这个线程还是可以重新回去poll一下，保证有效</span></span><br><span class="line">                    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> System.out.println(<span class="string">"销售了："</span> + t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考博文</p>
<p><a href="https://www.jianshu.com/p/d52fea0d6ba5" target="_blank" rel="noopener">java内存模型以及happens-before规则</a></p>
<h1 id="回答："><a href="#回答：" class="headerlink" title="回答："></a>回答：</h1><ol>
<li>JVM内存中的堆和方法区是线程共享的，那么他们存储的数据是可以被多个线程同时操作的，如果我们不加以并发控制，那么会造成数据不一致的问题。</li>
<li>并发，我了解的有几块内容：并发关键字、并发容器和线程池</li>
<li>并发关键字有synchronized、volatile、ReentranLock等，synchronized可以锁定方法或代码块中的实例对象，类对象来实现并发控制，保证原子性、可见性、有序性；除了volatile不能保证原子性外，它的作用与synchronized一样；而ReentranLock比synchronized更加灵活，是个手动锁，可以尝试锁定、还可设置公平锁</li>
<li>并发容器有ConcurrentHahsMap高并发的map的高并发的队列：</li>
</ol>

    </div>

    
    
    
        
      

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/08/31/JVM/" rel="next" title="">
                  <i class="fa fa-chevron-left"></i> 
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Inhaltsverzeichnis
        </li>
        <li class="sidebar-nav-overview">
          Übersicht
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Java内存模型"><span class="nav-number">1.</span> <span class="nav-text">1. Java内存模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-共享变量"><span class="nav-number">2.</span> <span class="nav-text">2. 共享变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-JMM抽象结构模型"><span class="nav-number">3.</span> <span class="nav-text">3. JMM抽象结构模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程并发"><span class="nav-number"></span> <span class="nav-text">线程并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronized互斥锁"><span class="nav-number">1.</span> <span class="nav-text">Synchronized互斥锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#被锁对象"><span class="nav-number">1.1.</span> <span class="nav-text">被锁对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-代码块中的实例对象Object"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. 代码块中的实例对象Object</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-代码块中的类实例对象-this"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. 代码块中的类实例对象 this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-代码块中的类对象"><span class="nav-number">1.1.3.</span> <span class="nav-text">3. 代码块中的类对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-实例方法上的类实例对象"><span class="nav-number">1.1.4.</span> <span class="nav-text">4. 实例方法上的类实例对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-静态方法上的类对象"><span class="nav-number">1.1.5.</span> <span class="nav-text">5. 静态方法上的类对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#性质"><span class="nav-number">1.2.</span> <span class="nav-text">性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步方法的调用问题"><span class="nav-number">1.3.</span> <span class="nav-text">同步方法的调用问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-同步与非同步方法是否可以同时调用"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 同步与非同步方法是否可以同时调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-一个同步方法是否可以调用另一个同步方法"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 一个同步方法是否可以调用另一个同步方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-子类是否可以调用父类的同步方法"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. 子类是否可以调用父类的同步方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-被锁对象的属性或引用的改变"><span class="nav-number">1.3.4.</span> <span class="nav-text">4. 被锁对象的属性或引用的改变</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常时释放锁"><span class="nav-number">1.4.</span> <span class="nav-text">异常时释放锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化"><span class="nav-number">1.5.</span> <span class="nav-text">优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile-关键字"><span class="nav-number">2.</span> <span class="nav-text">volatile 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#性质-1"><span class="nav-number">2.0.1.</span> <span class="nav-text">性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对比synchronized"><span class="nav-number">2.0.2.</span> <span class="nav-text">对比synchronized</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">3.</span> <span class="nav-text">ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#手动锁"><span class="nav-number">3.1.</span> <span class="nav-text">手动锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可”尝试锁定“"><span class="nav-number">3.2.</span> <span class="nav-text">可”尝试锁定“</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可打断等待"><span class="nav-number">3.3.</span> <span class="nav-text">可打断等待</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可指定公平锁"><span class="nav-number">3.4.</span> <span class="nav-text">可指定公平锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal-线程局部变量"><span class="nav-number">4.</span> <span class="nav-text">ThreadLocal 线程局部变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Singleton-单例模式"><span class="nav-number">5.</span> <span class="nav-text">Singleton 单例模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#并发容器"><span class="nav-number"></span> <span class="nav-text">并发容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Map-Set"><span class="nav-number">1.</span> <span class="nav-text">Map/Set</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#无并发"><span class="nav-number">1.1.</span> <span class="nav-text">无并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加锁低并发"><span class="nav-number">1.2.</span> <span class="nav-text">加锁低并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高并发"><span class="nav-number">1.3.</span> <span class="nav-text">高并发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#队列"><span class="nav-number">2.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#无并发-1"><span class="nav-number">2.1.</span> <span class="nav-text">无并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#低并发"><span class="nav-number">2.2.</span> <span class="nav-text">低并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高并发-1"><span class="nav-number">2.3.</span> <span class="nav-text">高并发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#非阻塞同步队列"><span class="nav-number">2.3.1.</span> <span class="nav-text">非阻塞同步队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ConcurrentLinkedQueue"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">ConcurrentLinkedQueue</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞同步队列BlockQueue"><span class="nav-number">2.3.2.</span> <span class="nav-text">阻塞同步队列BlockQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LinkedBlockingQueue"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">LinkedBlockingQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ArrayBlockingQueue"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">ArrayBlockingQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TransferQueue"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">TransferQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SynchronousQueue"><span class="nav-number">2.3.2.4.</span> <span class="nav-text">SynchronousQueue</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#延迟队列"><span class="nav-number">2.3.3.</span> <span class="nav-text">延迟队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#DelayQueue"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">DelayQueue</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程池"><span class="nav-number"></span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor"><span class="nav-number">0.1.</span> <span class="nav-text">Executor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ExecutorService"><span class="nav-number">0.2.</span> <span class="nav-text">ExecutorService</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字段含义"><span class="nav-number">0.2.1.</span> <span class="nav-text">字段含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Callable"><span class="nav-number">0.2.2.</span> <span class="nav-text">Callable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Future"><span class="nav-number">0.2.3.</span> <span class="nav-text">Future</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executors"><span class="nav-number">0.3.</span> <span class="nav-text">Executors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPool-线程池"><span class="nav-number">0.4.</span> <span class="nav-text">ThreadPool 线程池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-number">1.</span> <span class="nav-text">ThreadPoolExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于ThreadPoolExecutor创建的线程池"><span class="nav-number">1.1.</span> <span class="nav-text">基于ThreadPoolExecutor创建的线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-FixedThreadPool-固定容量线程池"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. FixedThreadPool 固定容量线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-CachedThreadPool-可缓存的线程池"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. CachedThreadPool 可缓存的线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-SingleThreadExecutor-单线程执行器"><span class="nav-number">1.1.3.</span> <span class="nav-text">3. SingleThreadExecutor 单线程执行器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-ScheduledThreadPool-调度线程池"><span class="nav-number">1.1.4.</span> <span class="nav-text">4. ScheduledThreadPool 调度线程池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于ForkJoinPool创建的线程池"><span class="nav-number">1.2.</span> <span class="nav-text">基于ForkJoinPool创建的线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-WorkStealingPool-工作窃取线程池"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. WorkStealingPool 工作窃取线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-ForkJoinPool-分治线程池"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. ForkJoinPool 分治线程池</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面试题"><span class="nav-number"></span> <span class="nav-text">面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-监控元素个数"><span class="nav-number">0.1.</span> <span class="nav-text">1.监控元素个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-生产者与消费者"><span class="nav-number">0.2.</span> <span class="nav-text">2.生产者与消费者</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-wait-notify"><span class="nav-number">0.2.1.</span> <span class="nav-text">a) wait/notify</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-lock与Condition"><span class="nav-number">0.2.2.</span> <span class="nav-text">b) lock与Condition</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-火车票销售"><span class="nav-number">0.3.</span> <span class="nav-text">3. 火车票销售</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#回答："><span class="nav-number"></span> <span class="nav-text">回答：</span></a></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.jpg"
      alt="qinnsang">
  <p class="site-author-name" itemprop="name">qinnsang</p>
  <div class="site-description" itemprop="description">Keep study</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">Artikel</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/QinnSang" title="GitHub &rarr; https://github.com/QinnSang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://cxxin1998@163.com" title="E-Mail &rarr; https://cxxin1998@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qinnsang</span>
</div>
  <div class="powered-by">Erstellt mit  <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Design – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.3.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/pisces.js?v=7.3.0"></script>

<script src="/js/next-boot.js?v=7.3.0"></script>



  





















  

  

  

</body>
</html>
